{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Iden3 Docs Welcome to the documentation site of the Iden3 project, future-proof tech stack for self-sovereign identity. Iden3 on GitHub Versatility of applications The main idea of the iden3 protocol is that each identity is self-soverign and can issue claims on another identity (which can be for an individual, an organisation or a system/machine). This simple and unique characteristics can lead to creation complex adaptive systems and the following use cases: Decentralised trust models / web-of-trust Decentralised ID verification / proof-of-personhood Decentralised voting systems Interaction with DeFi / dApps / Web3 Decentralised payment identifiers Private access control Authentication and authorisation Signing documents and private messaging Supply chain and IoT NFT ownership Iden3 protocol libraries Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Home"},{"location":"#iden3-docs","text":"Welcome to the documentation site of the Iden3 project, future-proof tech stack for self-sovereign identity.","title":"Iden3 Docs"},{"location":"#iden3-on-github","text":"","title":"Iden3 on GitHub"},{"location":"#versatility-of-applications","text":"The main idea of the iden3 protocol is that each identity is self-soverign and can issue claims on another identity (which can be for an individual, an organisation or a system/machine). This simple and unique characteristics can lead to creation complex adaptive systems and the following use cases: Decentralised trust models / web-of-trust Decentralised ID verification / proof-of-personhood Decentralised voting systems Interaction with DeFi / dApps / Web3 Decentralised payment identifiers Private access control Authentication and authorisation Signing documents and private messaging Supply chain and IoT NFT ownership","title":"Versatility of applications"},{"location":"#iden3-protocol-libraries","text":"Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Iden3 protocol libraries"},{"location":"basics/getting-started/","text":"Getting Started Zero-knowledge Proofs To learn how to create zero-knowledge proofs, have a look at Circom and SnarkJS guide . The process starts with employing various techniques of writing circuits for zero-knowledge proofs; it then moves on to creating and verifying a proof off-chain and finishes off by showing you how to replicate the process on-chain with Ethereum. Services and Protocols To get started with any of our services/protocols, have a look here .","title":"Getting started"},{"location":"basics/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"basics/getting-started/#zero-knowledge-proofs","text":"To learn how to create zero-knowledge proofs, have a look at Circom and SnarkJS guide . The process starts with employing various techniques of writing circuits for zero-knowledge proofs; it then moves on to creating and verifying a proof off-chain and finishes off by showing you how to replicate the process on-chain with Ethereum.","title":"Zero-knowledge Proofs"},{"location":"basics/getting-started/#services-and-protocols","text":"To get started with any of our services/protocols, have a look here .","title":"Services and Protocols"},{"location":"basics/introduction/","text":"Introduction Identity is a uniquely human concept. It is that ineffable \u201cI\u201d of self-consciousness, something that is understood worldwide by every person living in every culture. As Ren\u00e9 Descartes said, Cogito ergo sum \u2014 I think, therefore I am. ( Source ) What constitutes your identity? What makes you who you are? What is it about you that distinguishes you from others? Philosophers have argued over these questions since the beginning of civilization. Suffice to say there are no simple answers. Identity is a difficult concept to pin down. Nevertheless, we don't need a precise definition to see that there are problems with how modern society thinks about identity. In the words of Christopher Allen : Today, nations and corporations conflate driver\u2019s licenses, social security cards, and other state-issued credentials with identity; this is problematic because it suggests a person can lose his very identity if a state revokes his credentials or even if he just crosses state borders. I think, but I am not. How can we improve on this? It is clear that we are at an inflection point for how the digital world interacts with the physical world. The legacy systems of the physical world have not kept up with the rising importance of the digital world. As both worlds continue to merge, this scenario will need to change. This gives us an opportunity to create systems -- from the ground up -- that bridge the two. The systems that operate with a different concept of identity. If we design them well, these systems will allow us to redefine how modern society thinks about identity. Perhaps getting us closer to that ineffable \"I\" of self-consciousness. At Iden3, we're focused on building the tools and developing the protocols to make this happen.","title":"Introduction"},{"location":"basics/introduction/#introduction","text":"Identity is a uniquely human concept. It is that ineffable \u201cI\u201d of self-consciousness, something that is understood worldwide by every person living in every culture. As Ren\u00e9 Descartes said, Cogito ergo sum \u2014 I think, therefore I am. ( Source ) What constitutes your identity? What makes you who you are? What is it about you that distinguishes you from others? Philosophers have argued over these questions since the beginning of civilization. Suffice to say there are no simple answers. Identity is a difficult concept to pin down. Nevertheless, we don't need a precise definition to see that there are problems with how modern society thinks about identity. In the words of Christopher Allen : Today, nations and corporations conflate driver\u2019s licenses, social security cards, and other state-issued credentials with identity; this is problematic because it suggests a person can lose his very identity if a state revokes his credentials or even if he just crosses state borders. I think, but I am not. How can we improve on this? It is clear that we are at an inflection point for how the digital world interacts with the physical world. The legacy systems of the physical world have not kept up with the rising importance of the digital world. As both worlds continue to merge, this scenario will need to change. This gives us an opportunity to create systems -- from the ground up -- that bridge the two. The systems that operate with a different concept of identity. If we design them well, these systems will allow us to redefine how modern society thinks about identity. Perhaps getting us closer to that ineffable \"I\" of self-consciousness. At Iden3, we're focused on building the tools and developing the protocols to make this happen.","title":"Introduction"},{"location":"basics/key-concepts/","text":"Key Concepts Identity At iden3, our goal is to democratize identity. We believe that everyone should be empowered to become their own certification authority . What Do We Mean by Identity? An identity can be a person, a company, an organization, a DAO , or a government. Identity can even be a thing: a chair, a room, a bot, and so on. When we talk about identities, we are referring to \"identities as accounts\". Generally speaking, these accounts are going to be smart contracts. So you can think of identities as smart contracts , where the address of the contract is the identifier of that identity. Key Takeaways : Anything can be an identity. One person can define and have many identities. In Ethereum, an identity is an account or a smart contract. Claims An identity can provide a claim. You can think of a claim as a statement: something an identity is saying. Most of the time, these statements refer to other identities. In other words, claims usually create relations between identities. For example, when a university (identity) says that a student (identity) has a degree, this is a statement (claim) about the student. This statement creates a relation between the student and the university. Claims can be public or private. And it turns out that almost anything we say or do can be thought of as a claim. Company invoices, Facebook likes, and email messages can all be thought of as claims. Examples of Claims A certificate (e.g. birth certificate) A debt recognition An invoice An Instagram \"Like\" An endorsement (reputation) An email A driving license A role in a company ... Almost anything! Direct Claims If an identity wants to create many claims, it can put all the claims in a database, construct a Merkle tree of that database, and just publish (with a transaction) the root of the Merkle tree on-chain. If the identity wants to update the claims later, it can repeat the same process and publish the new root of the Merkle tree. For example, one could imagine a government adding/modifying millions of claims in a single transaction. Indirect Claims While direct claims scale really well for identities that make a lot of claims (since millions of claims can be batched in a single transaction), an average user will probably only need to make a few claims a day, and so won't benefit from this batching. This is where indirect claims come in handy. Instead of paying gas every time to update the Merkle root on-chain, indirect claims allow users to send claims off-chain to a relayer . The idea is that with relayers, millions of users can create millions of claims on mainnet without spending any gas (since the relayer is responsible for batching the claims and publishing the transactions). On top of this, using zero-knowledge proofs , we can ensure that the relayer is trustless. In other words, we can make sure that the relayer can't lie about the claims we sent it. The worst a relayer can do is to not publish them (and if this happens, we, as the users, always have the choice to change relayers). Zero-knowledge Proofs In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. ( Source ) In other words, zero-knowledge proofs allow us to prove something specific without revealing any extra information. Why do we care? Simply put, when we're talking about claims, sometimes, we want to prove things in a private manner. Examples Nightclub Entry Say you want to enter a nightclub, and you need to prove to the bouncer that you are over 18. But you don't want to reveal to him your name, address, or anything else that's not relevant. With zero-knowledge proof, you can prove that you hold the key that belongs to an identity that the state says is over 18, without revealing anything else about that identity. ICO Participation Say an ICO is available only to the KYC-approved or authorized users. With zk proofs, you can prove that you are an authorized person to participate in the ICO without revealing who you are or how much you spent. Anonymous Voting Similar to the above, zk proofs allow you to prove that you are an eligible identity, without revealing your identity. Non-reusable Proofs A non-reusable proof is a received proof that is not valid to be sent to a third identity. For example, imagine that you belong to a political party, P. And P has made a private claim that you belong to it. Now, you want to prove to another identity that you belong to P, but you don't want that this identity can pass on that proof to others. In other words, you want to make sure the proof stays between the two of you.We can do this using zero-knowledge proofs. How? To prove something - let's call it A - we can create a new proof called B that is valid either if A is valid or we know the private key of the recipient, R. Clearly, we don't know R's private key, so when we share a valid proof B with R, R knows that A must be valid. To see why B is non-reusable, let us suppose that R wants to share B with another recipient R'. Now, from the perspective of R', B is valid either if A is valid or R knows its own private key. But since R clearly knows its private key, R' can't tell whether A is valid or not. ZK-SNARKs You can think of zk-SNARKs as an efficient way to produce zero-knowledge proofs. These are the proofs that are short enough to be published on blockchain and that can be read later by a verifier. Merkle Trees A Merkle tree is a binary tree built using hash pointers (if you're unfamiliar with what a hash pointer or function is, see the definitions section at the bottom of this page). We care about Merkle trees because we want to build a data structure that: Can store lots of data ( scalability ) Makes it easy to prove that some data exists ( proof of membership ) Allows us to check that data hasn't been altered ( tamper resistance ) Merkle trees satisfy the three properties mentioned above. Specifications Before we take a closer look at these properties, let's go through how to build a Merkle tree with some data. Suppose we have several blocks containing data and that these blocks form the leaves of our tree. The first step is to create a parent node for each data block. These parent nodes form the next level in the tree and store the hash of their descendent data block. Next, we group these parent nodes into pairs and store the hash of each pair one level up the tree. We continue doing this until we are left with a single block, the root of the tree, also called Merkle Root. Tamper Resistance It turns out that any attempt to tamper with any piece of data can be detected by simply remembering the hash at the root of the tree. To understand why this is the case, let\u2019s look at what happens if an adversary wants to tamper with a data block. If an adversary tampers with a block at the leaf of our tree, it will cause the mismatch with the hash in the node that\u2019s one level up. So the adversary will have to tamper with that too. This means s/he has to tamper with the node one level up from there. And so on\u2026 Eventually, s/he will get to the root. If s/he tries to tamper with the root too, we\u2019ll know because this is the node we\u2019ve kept track of. Proof of Membership Merkle trees allow us to quickly check membership (through a neat mechanism known as Merkle proofs). What do we mean by that? Suppose, as usual, we remember just the root (on-chain). And we want to prove that a certain data block\u200a-\u200adata0\u200a-\u200ais a member of the Merkle tree. All we need are the blocks on the path from the data block to the root. And each of data0's siblings on the way up. We can ignore the rest of the tree, as these blocks are enough to allow us to verify the hashes all the way up to the root of the tree. But how? The idea is to recalculate the root by recursively hashing the data. If the calculated root is equal to the on-chain root, it proves that the data block exists in the Merkle tree. In our case, we start by calculating the hash of data0 and storing it in the block labeled 0. We then calculate the hash of the hash of data0 concatenated with the hash of data1. In other words, we calculate the hash of the concatenation of blocks 0 and 1\u200aand store it in block 4. Finally, we calculate the hash of blocks 4 and 5 to obtain the recalculated root. If the calculated root is equal to the on-chain root, we\u2019ve proven that data0 exists in the Merkle tree. In technical terms: This means that if there are n nodes in the tree, only about log(n) items need to be shown. And since each step just requires computing the hash of the child block, it takes about log(n) time for us to verify it. And so even if the Merkle tree contains a very large number of blocks, we can still prove membership in a relatively short time. Verification thus runs in time and space that\u2019s logarithmic in the number of nodes in the tree. ( Source (pg 35)) Scalability Storing data on a blockchain is expensive. Merkle trees help us in minimizing the amount of data stored on-chain. How? As we saw in the previous sections, to ensure tamper-resistance and Proof of Membership, we need to store only the root of the tree, not the whole tree. This means that no matter how big the tree is, the only piece of data we actually need to store on-chain is the root. Sparse Merkle Trees At iden3, we use a slightly more complex data structure called a sparse Merkle tree. A sparse Merkle tree is like a standard Merkle tree, except that its contained data is indexed, and each data block is placed at the leaf that corresponds to that block's index. In addition to inheriting the tamper-resistance and proof of membership properties from normal Merkle trees, sparse Merkle trees make it easy to prove that some data doesn\u2019t exist ( proof of non-membership ). Proof of Non-membership Now consider that we only have two pieces of data -- data0 and data3 -- with indices 0 and 3 respectively. To construct a sparse Merkle tree, we populate the 0th and 3rd leaves with this data, leaving the 1st and 2nd leaves empty. Well, almost empty! To be precise, we fill the 1st and 2nd leaves in with a special placeholder value like null . With this placeholder, we can now build up the rest of the tree. Now, what happens if we want to prove that a piece of (indexed) data -- data2 -- is not a member of this tree? Thanks to the way our data is indexed, proving that data2 is not a member of the tree is equivalent to proving that the value of the leaf at index 2 is null ! Put another way, proving non-membership of a data block is equivalent to proving membership of null (a simple Merkle proof). And as we saw in our previous post, doing this efficiently is a basic property of a Merkle tree. Summary By indexing data and making leaves empty, sparse Merkle trees allow us to reframe proofs of non-membership into proofs of membership (a.k.a Merkle proofs), making it easy to prove that some data does not exist. One drawback to sparse Merkle trees is that they are really big. This means that without optimizations, read and write operations can be quite inefficient. For example, a sparse Merkle tree usually has 2^256 leaves vs. 2^32 for a normal Merkle tree. This means that naive implementations require 256 operations to read or write (vs 32). Luckily, these sorts of inefficiencies are largely illusory. Since fairly simple optimizations exist to get around them! Note: while we won't get into the details here, one of the keys to these optimizations is that sparse Merkle trees are mostly sparse. This means many of the subtrees will end up being zero subtrees. Since H(0), H(H(0)), H(H(H(0))), and so on are all constant values, the zero-subtrees can be cached (calculated once, stored, and then omitted from Merkle proofs), greatly reducing the size of computations. Why Do We use Merkle Trees at iden3? At iden3, one of our major goals is scalability. Specifically, we believe that anybody should be able to create as many identities as they want. And that any identity should be able to generate as many claims as it wants. Imagine if you had to make a new transaction to the blockchain every time you wanted to make a new claim? Even worse, imagine you're a government and you're responsible for making millions of claims every day! Achieving this goal requires minimizing the amount of data stored on-chain. This is where Merkle trees come into the picture. Even if you're a government that is making millions of claims a day, you can just construct a tree (off-chain) with each claim as a separate data block, and simply calculate and store the root on-chain. In other words, Merkle trees allow prolific claim generators to add/modify millions of claims in a single transaction. This makes it easy to scale the claims. Definitions Hash Functions A hash function maps an input string of any size to an output string of a fixed size. It must be efficiently computable (for any given input string, we can figure out the output of the hash function in a reasonable amount of time. More technically, computing the hash of an n\u2010bit string should have a running time that is O(n)). For a hash function to be cryptographically secure, it must have three additional properties: Collision Resistance Hiding Puzzle-friendliness While we would not get into the details here, let's briefly discuss what each of these properties stands for. Collision Resistance means that nobody can find two inputs that map to the same output. Hiding means that given an output there's no feasible way to figure out the input that generated it. Puzzle-friendliness is a little more complicated. Intuitively, it means that it is very hard to target the hash function to come out to some particular output value y. Don't worry if you can't understand why this property is useful. In our context of things, it is not very important. Hash Pointers A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. A pointer gives you a way to retrieve the information, whereas a hash pointer gives you a way to verify that the information hasn\u2019t changed. In other words, a hash pointer is a pointer to where data is stored along with a cryptographic hash of the value of that data at some fixed point in time. If at some point in the future, we want to check if the data hasn't changed, we simply hash the data again and verify that the new output (cryptographic hash) matches the previous output. This works because we know by the collision resistance property of the hash function that nobody can find two inputs that map to the same output. So if the output is the same, the input must also have been the same.","title":"Key concepts"},{"location":"basics/key-concepts/#key-concepts","text":"","title":"Key Concepts"},{"location":"basics/key-concepts/#identity","text":"At iden3, our goal is to democratize identity. We believe that everyone should be empowered to become their own certification authority . What Do We Mean by Identity? An identity can be a person, a company, an organization, a DAO , or a government. Identity can even be a thing: a chair, a room, a bot, and so on. When we talk about identities, we are referring to \"identities as accounts\". Generally speaking, these accounts are going to be smart contracts. So you can think of identities as smart contracts , where the address of the contract is the identifier of that identity. Key Takeaways : Anything can be an identity. One person can define and have many identities. In Ethereum, an identity is an account or a smart contract.","title":"Identity"},{"location":"basics/key-concepts/#claims","text":"An identity can provide a claim. You can think of a claim as a statement: something an identity is saying. Most of the time, these statements refer to other identities. In other words, claims usually create relations between identities. For example, when a university (identity) says that a student (identity) has a degree, this is a statement (claim) about the student. This statement creates a relation between the student and the university. Claims can be public or private. And it turns out that almost anything we say or do can be thought of as a claim. Company invoices, Facebook likes, and email messages can all be thought of as claims.","title":"Claims"},{"location":"basics/key-concepts/#examples-of-claims","text":"A certificate (e.g. birth certificate) A debt recognition An invoice An Instagram \"Like\" An endorsement (reputation) An email A driving license A role in a company ... Almost anything!","title":"Examples of Claims"},{"location":"basics/key-concepts/#direct-claims","text":"If an identity wants to create many claims, it can put all the claims in a database, construct a Merkle tree of that database, and just publish (with a transaction) the root of the Merkle tree on-chain. If the identity wants to update the claims later, it can repeat the same process and publish the new root of the Merkle tree. For example, one could imagine a government adding/modifying millions of claims in a single transaction.","title":"Direct Claims"},{"location":"basics/key-concepts/#indirect-claims","text":"While direct claims scale really well for identities that make a lot of claims (since millions of claims can be batched in a single transaction), an average user will probably only need to make a few claims a day, and so won't benefit from this batching. This is where indirect claims come in handy. Instead of paying gas every time to update the Merkle root on-chain, indirect claims allow users to send claims off-chain to a relayer . The idea is that with relayers, millions of users can create millions of claims on mainnet without spending any gas (since the relayer is responsible for batching the claims and publishing the transactions). On top of this, using zero-knowledge proofs , we can ensure that the relayer is trustless. In other words, we can make sure that the relayer can't lie about the claims we sent it. The worst a relayer can do is to not publish them (and if this happens, we, as the users, always have the choice to change relayers).","title":"Indirect Claims"},{"location":"basics/key-concepts/#zero-knowledge-proofs","text":"In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. ( Source ) In other words, zero-knowledge proofs allow us to prove something specific without revealing any extra information. Why do we care? Simply put, when we're talking about claims, sometimes, we want to prove things in a private manner.","title":"Zero-knowledge Proofs"},{"location":"basics/key-concepts/#examples","text":"","title":"Examples"},{"location":"basics/key-concepts/#nightclub-entry","text":"Say you want to enter a nightclub, and you need to prove to the bouncer that you are over 18. But you don't want to reveal to him your name, address, or anything else that's not relevant. With zero-knowledge proof, you can prove that you hold the key that belongs to an identity that the state says is over 18, without revealing anything else about that identity.","title":"Nightclub Entry"},{"location":"basics/key-concepts/#ico-participation","text":"Say an ICO is available only to the KYC-approved or authorized users. With zk proofs, you can prove that you are an authorized person to participate in the ICO without revealing who you are or how much you spent.","title":"ICO Participation"},{"location":"basics/key-concepts/#anonymous-voting","text":"Similar to the above, zk proofs allow you to prove that you are an eligible identity, without revealing your identity.","title":"Anonymous Voting"},{"location":"basics/key-concepts/#non-reusable-proofs","text":"A non-reusable proof is a received proof that is not valid to be sent to a third identity. For example, imagine that you belong to a political party, P. And P has made a private claim that you belong to it. Now, you want to prove to another identity that you belong to P, but you don't want that this identity can pass on that proof to others. In other words, you want to make sure the proof stays between the two of you.We can do this using zero-knowledge proofs. How? To prove something - let's call it A - we can create a new proof called B that is valid either if A is valid or we know the private key of the recipient, R. Clearly, we don't know R's private key, so when we share a valid proof B with R, R knows that A must be valid. To see why B is non-reusable, let us suppose that R wants to share B with another recipient R'. Now, from the perspective of R', B is valid either if A is valid or R knows its own private key. But since R clearly knows its private key, R' can't tell whether A is valid or not.","title":"Non-reusable Proofs"},{"location":"basics/key-concepts/#zk-snarks","text":"You can think of zk-SNARKs as an efficient way to produce zero-knowledge proofs. These are the proofs that are short enough to be published on blockchain and that can be read later by a verifier.","title":"ZK-SNARKs"},{"location":"basics/key-concepts/#merkle-trees","text":"A Merkle tree is a binary tree built using hash pointers (if you're unfamiliar with what a hash pointer or function is, see the definitions section at the bottom of this page). We care about Merkle trees because we want to build a data structure that: Can store lots of data ( scalability ) Makes it easy to prove that some data exists ( proof of membership ) Allows us to check that data hasn't been altered ( tamper resistance ) Merkle trees satisfy the three properties mentioned above.","title":"Merkle Trees"},{"location":"basics/key-concepts/#specifications","text":"Before we take a closer look at these properties, let's go through how to build a Merkle tree with some data. Suppose we have several blocks containing data and that these blocks form the leaves of our tree. The first step is to create a parent node for each data block. These parent nodes form the next level in the tree and store the hash of their descendent data block. Next, we group these parent nodes into pairs and store the hash of each pair one level up the tree. We continue doing this until we are left with a single block, the root of the tree, also called Merkle Root.","title":"Specifications"},{"location":"basics/key-concepts/#tamper-resistance","text":"It turns out that any attempt to tamper with any piece of data can be detected by simply remembering the hash at the root of the tree. To understand why this is the case, let\u2019s look at what happens if an adversary wants to tamper with a data block. If an adversary tampers with a block at the leaf of our tree, it will cause the mismatch with the hash in the node that\u2019s one level up. So the adversary will have to tamper with that too. This means s/he has to tamper with the node one level up from there. And so on\u2026 Eventually, s/he will get to the root. If s/he tries to tamper with the root too, we\u2019ll know because this is the node we\u2019ve kept track of.","title":"Tamper Resistance"},{"location":"basics/key-concepts/#proof-of-membership","text":"Merkle trees allow us to quickly check membership (through a neat mechanism known as Merkle proofs). What do we mean by that? Suppose, as usual, we remember just the root (on-chain). And we want to prove that a certain data block\u200a-\u200adata0\u200a-\u200ais a member of the Merkle tree. All we need are the blocks on the path from the data block to the root. And each of data0's siblings on the way up. We can ignore the rest of the tree, as these blocks are enough to allow us to verify the hashes all the way up to the root of the tree. But how? The idea is to recalculate the root by recursively hashing the data. If the calculated root is equal to the on-chain root, it proves that the data block exists in the Merkle tree. In our case, we start by calculating the hash of data0 and storing it in the block labeled 0. We then calculate the hash of the hash of data0 concatenated with the hash of data1. In other words, we calculate the hash of the concatenation of blocks 0 and 1\u200aand store it in block 4. Finally, we calculate the hash of blocks 4 and 5 to obtain the recalculated root. If the calculated root is equal to the on-chain root, we\u2019ve proven that data0 exists in the Merkle tree. In technical terms: This means that if there are n nodes in the tree, only about log(n) items need to be shown. And since each step just requires computing the hash of the child block, it takes about log(n) time for us to verify it. And so even if the Merkle tree contains a very large number of blocks, we can still prove membership in a relatively short time. Verification thus runs in time and space that\u2019s logarithmic in the number of nodes in the tree. ( Source (pg 35))","title":"Proof of Membership"},{"location":"basics/key-concepts/#scalability","text":"Storing data on a blockchain is expensive. Merkle trees help us in minimizing the amount of data stored on-chain. How? As we saw in the previous sections, to ensure tamper-resistance and Proof of Membership, we need to store only the root of the tree, not the whole tree. This means that no matter how big the tree is, the only piece of data we actually need to store on-chain is the root.","title":"Scalability"},{"location":"basics/key-concepts/#sparse-merkle-trees","text":"At iden3, we use a slightly more complex data structure called a sparse Merkle tree. A sparse Merkle tree is like a standard Merkle tree, except that its contained data is indexed, and each data block is placed at the leaf that corresponds to that block's index. In addition to inheriting the tamper-resistance and proof of membership properties from normal Merkle trees, sparse Merkle trees make it easy to prove that some data doesn\u2019t exist ( proof of non-membership ).","title":"Sparse Merkle Trees"},{"location":"basics/key-concepts/#proof-of-non-membership","text":"Now consider that we only have two pieces of data -- data0 and data3 -- with indices 0 and 3 respectively. To construct a sparse Merkle tree, we populate the 0th and 3rd leaves with this data, leaving the 1st and 2nd leaves empty. Well, almost empty! To be precise, we fill the 1st and 2nd leaves in with a special placeholder value like null . With this placeholder, we can now build up the rest of the tree. Now, what happens if we want to prove that a piece of (indexed) data -- data2 -- is not a member of this tree? Thanks to the way our data is indexed, proving that data2 is not a member of the tree is equivalent to proving that the value of the leaf at index 2 is null ! Put another way, proving non-membership of a data block is equivalent to proving membership of null (a simple Merkle proof). And as we saw in our previous post, doing this efficiently is a basic property of a Merkle tree.","title":"Proof of Non-membership"},{"location":"basics/key-concepts/#summary","text":"By indexing data and making leaves empty, sparse Merkle trees allow us to reframe proofs of non-membership into proofs of membership (a.k.a Merkle proofs), making it easy to prove that some data does not exist. One drawback to sparse Merkle trees is that they are really big. This means that without optimizations, read and write operations can be quite inefficient. For example, a sparse Merkle tree usually has 2^256 leaves vs. 2^32 for a normal Merkle tree. This means that naive implementations require 256 operations to read or write (vs 32). Luckily, these sorts of inefficiencies are largely illusory. Since fairly simple optimizations exist to get around them! Note: while we won't get into the details here, one of the keys to these optimizations is that sparse Merkle trees are mostly sparse. This means many of the subtrees will end up being zero subtrees. Since H(0), H(H(0)), H(H(H(0))), and so on are all constant values, the zero-subtrees can be cached (calculated once, stored, and then omitted from Merkle proofs), greatly reducing the size of computations.","title":"Summary"},{"location":"basics/key-concepts/#why-do-we-use-merkle-trees-at-iden3","text":"At iden3, one of our major goals is scalability. Specifically, we believe that anybody should be able to create as many identities as they want. And that any identity should be able to generate as many claims as it wants. Imagine if you had to make a new transaction to the blockchain every time you wanted to make a new claim? Even worse, imagine you're a government and you're responsible for making millions of claims every day! Achieving this goal requires minimizing the amount of data stored on-chain. This is where Merkle trees come into the picture. Even if you're a government that is making millions of claims a day, you can just construct a tree (off-chain) with each claim as a separate data block, and simply calculate and store the root on-chain. In other words, Merkle trees allow prolific claim generators to add/modify millions of claims in a single transaction. This makes it easy to scale the claims.","title":"Why Do We use Merkle Trees at iden3?"},{"location":"basics/key-concepts/#definitions","text":"","title":"Definitions"},{"location":"basics/key-concepts/#hash-functions","text":"A hash function maps an input string of any size to an output string of a fixed size. It must be efficiently computable (for any given input string, we can figure out the output of the hash function in a reasonable amount of time. More technically, computing the hash of an n\u2010bit string should have a running time that is O(n)). For a hash function to be cryptographically secure, it must have three additional properties: Collision Resistance Hiding Puzzle-friendliness While we would not get into the details here, let's briefly discuss what each of these properties stands for. Collision Resistance means that nobody can find two inputs that map to the same output. Hiding means that given an output there's no feasible way to figure out the input that generated it. Puzzle-friendliness is a little more complicated. Intuitively, it means that it is very hard to target the hash function to come out to some particular output value y. Don't worry if you can't understand why this property is useful. In our context of things, it is not very important.","title":"Hash Functions"},{"location":"basics/key-concepts/#hash-pointers","text":"A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. A pointer gives you a way to retrieve the information, whereas a hash pointer gives you a way to verify that the information hasn\u2019t changed. In other words, a hash pointer is a pointer to where data is stored along with a cryptographic hash of the value of that data at some fixed point in time. If at some point in the future, we want to check if the data hasn't changed, we simply hash the data again and verify that the new output (cryptographic hash) matches the previous output. This works because we know by the collision resistance property of the hash function that nobody can find two inputs that map to the same output. So if the output is the same, the input must also have been the same.","title":"Hash Pointers"},{"location":"basics/more-on-identity/","text":"More on Decentralized Identity Why Does Identity Matter? In the words of Vitalik : Mechanisms that do not rely on identity cannot solve the problem of concentrated interests outcompeting dispersed communities; an identity-free mechanism that empowers distributed communities cannot avoid over-empowering centralized plutocrats pretending to be distributed communities. In other words, without an identity mechanism, one can't ensure \"one human, one address\" or \"one human, one vote\". This means that however you structure the rules of the system, those with the most resources would be able to game it. How Is the Existing System Failing Us? In recent times, identities have been verified by credentials such as a passport or a social network account issued by a central authority (usually a state or corporation). However, as noted in Verifying Identity as a Social Intersection , such identity systems have several interrelated flaws: They are insecure . Crucial data such as an ID number constantly has to be given out. This is enough to impersonate an individual. On top of this, since all data is stored in a single repository managed by the state or a corporation, it becomes particularly vulnerable to hacking or internal corruption. They narrow you down to one thing (in the system or out, a criminal or not, a credit score, etc.). The central database has little use for more information than this. This limits the functionality of the system and results in great injustices (for example, convicted individuals find it hard to re-enter society as this is the only information about them that they can reliably convey). They are artificial in the sense that the information stored about you usually bears little relation to what you or your friends think of you about your identity. To quote directly from the paper: Recently, new identity paradigms have tried to get around some of these elements. One approach, adopted by \"big data\" platforms like Facebook and Google, is to overcome thinness [narrowness] by storing enormous amounts of detailed information about each individual. we might call this \"panoptic identity\". However, such solutions have greatly exacerbated the other two problems, as they require extremely artificial compromises to intimacy through the global sharing of data with platforms that would not otherwise store it, creating exceptional potential security risks. Why Do We Need This Vision Now? Given the rising political polarization and the increasing amount of information collected, shared, and cross-correlated by governments and corporations, there's a real risk that our information will be used against us in ways we cannot imagine. If history has taught us anything, it's that power belongs to those who control the information . Right now, that power belongs to the gatekeepers of our identities: governments and corporations. In an increasingly uncertain world, there's a real risk that general fear, discontent and polarization will result in that power being abused. In such a world, a check on the government and corporate power that goes beyond formal legal protection is essential. By putting the control of information back in our hands, decentralized identity systems provide a natural technological check on the ability of the governments and corporations to abuse their power. How Can the Developing World Benefit? In the developing world, decentralized identity systems have the potential to help bring millions of people out of the clutches of poverty. To quote the words of Timothy Ruff : Most of us take for granted that we can prove things about ourselves, unaware that over a billion people cannot. Identity is a prerequisite to financial inclusion, and financial inclusion is a big part of solving poverty. What Are Some of the Use Cases? Liquid Democracy Imagine if you could vote every two weeks to express your political sentiments regarding interest rates. Imagine if you could have a direct say in any decision rather than relying on elected politicians to represent you. Imagine if those in power were held accountable in real-time rather than once every few years. This is the promise of liquid democracy. Liquid democracy exists somewhere in the sweet spot between direct and representative democracy. As with direct democracy, everyone has the opportunity to vote on every issue. However, unlike direct democracy, you also have the choice to delegate your vote to someone else. You can even choose to delegate your votes on different issues to different people. For example, on environmental issues, you might choose to delegate your vote to your favourite environmentalist. Whereas on issues concerning government debt and taxation you might choose your father. This ability to delegate is recursive. It means that if your father, in turn, chooses to delegate his vote on financial issues to his favourite economist, your vote will also be delegated to that economist. If you're unhappy with your father's decision, you can take that power away from him/her, and either vote yourself or re-delegate to someone you deem more trustworthy. Under such a system, those with the most delegations become our representatives. But unlike representative democracy, they are held accountable in real-time. A system like this addresses the uninformed voters' issue that a direct democracy creates by allowing these voters allot their votes to experts. It also addresses the corruption issues of representative democracy because citizens can rescind their vote from someone instantly, forcing delegates to vote in the best interest of their constituents. It is the best of both worlds that truly gives the power of influence to the voters. ( Source ) This sounds almost too good to be true. A fair, transparent, and corruption-free government! Why haven't we implemented this before? Since there is no central government under this form of democracy, we need to figure out how to allow citizens to vote in a secure, private, and decentralized way. It turns out this is a pretty hard problem to solve. It has actually been impossible to solve. Until now. This is the first time in our history that technology exists to turn this dream into reality. Of course, we're talking about public blockchains. Right now, we're in the experimentation phase. There are still some hard challenges that need to be overcome. The three main challenges revolve around scalability , privacy , and Sybil attacks . Scalability is important because we need millions of people to be able to use these systems. Privacy is important because it ensures voters can't be discriminated against for the decisions they make. It also makes it harder for them to be bribed/coerced into voting for something they don't believe in. But perhaps the hardest challenge is to ensure that one person is not able to vote multiple times (what's known in the jargon as a Sybil attack). The key to solving the last two challenges is a voting protocol that requires basic verification and reputation for each user whilst protecting their pseudonymous identity. In other words, a voting protocol with a built-in decentralized identity system. Put another way, decentralized identity is the big unlock that's needed to turn liquid democracy into a reality. P.S. It turns out that solving the privacy problem helps solve the scalability problem too, but we won't get into that here.","title":"More on Decentralized Identity"},{"location":"basics/more-on-identity/#more-on-decentralized-identity","text":"","title":"More on Decentralized Identity"},{"location":"basics/more-on-identity/#why-does-identity-matter","text":"In the words of Vitalik : Mechanisms that do not rely on identity cannot solve the problem of concentrated interests outcompeting dispersed communities; an identity-free mechanism that empowers distributed communities cannot avoid over-empowering centralized plutocrats pretending to be distributed communities. In other words, without an identity mechanism, one can't ensure \"one human, one address\" or \"one human, one vote\". This means that however you structure the rules of the system, those with the most resources would be able to game it.","title":"Why Does Identity Matter?"},{"location":"basics/more-on-identity/#how-is-the-existing-system-failing-us","text":"In recent times, identities have been verified by credentials such as a passport or a social network account issued by a central authority (usually a state or corporation). However, as noted in Verifying Identity as a Social Intersection , such identity systems have several interrelated flaws: They are insecure . Crucial data such as an ID number constantly has to be given out. This is enough to impersonate an individual. On top of this, since all data is stored in a single repository managed by the state or a corporation, it becomes particularly vulnerable to hacking or internal corruption. They narrow you down to one thing (in the system or out, a criminal or not, a credit score, etc.). The central database has little use for more information than this. This limits the functionality of the system and results in great injustices (for example, convicted individuals find it hard to re-enter society as this is the only information about them that they can reliably convey). They are artificial in the sense that the information stored about you usually bears little relation to what you or your friends think of you about your identity. To quote directly from the paper: Recently, new identity paradigms have tried to get around some of these elements. One approach, adopted by \"big data\" platforms like Facebook and Google, is to overcome thinness [narrowness] by storing enormous amounts of detailed information about each individual. we might call this \"panoptic identity\". However, such solutions have greatly exacerbated the other two problems, as they require extremely artificial compromises to intimacy through the global sharing of data with platforms that would not otherwise store it, creating exceptional potential security risks.","title":"How Is the Existing System Failing Us?"},{"location":"basics/more-on-identity/#why-do-we-need-this-vision-now","text":"Given the rising political polarization and the increasing amount of information collected, shared, and cross-correlated by governments and corporations, there's a real risk that our information will be used against us in ways we cannot imagine. If history has taught us anything, it's that power belongs to those who control the information . Right now, that power belongs to the gatekeepers of our identities: governments and corporations. In an increasingly uncertain world, there's a real risk that general fear, discontent and polarization will result in that power being abused. In such a world, a check on the government and corporate power that goes beyond formal legal protection is essential. By putting the control of information back in our hands, decentralized identity systems provide a natural technological check on the ability of the governments and corporations to abuse their power.","title":"Why Do We Need This Vision Now?"},{"location":"basics/more-on-identity/#how-can-the-developing-world-benefit","text":"In the developing world, decentralized identity systems have the potential to help bring millions of people out of the clutches of poverty. To quote the words of Timothy Ruff : Most of us take for granted that we can prove things about ourselves, unaware that over a billion people cannot. Identity is a prerequisite to financial inclusion, and financial inclusion is a big part of solving poverty.","title":"How Can the Developing World Benefit?"},{"location":"basics/more-on-identity/#what-are-some-of-the-use-cases","text":"","title":"What Are Some of the Use Cases?"},{"location":"basics/more-on-identity/#liquid-democracy","text":"Imagine if you could vote every two weeks to express your political sentiments regarding interest rates. Imagine if you could have a direct say in any decision rather than relying on elected politicians to represent you. Imagine if those in power were held accountable in real-time rather than once every few years. This is the promise of liquid democracy. Liquid democracy exists somewhere in the sweet spot between direct and representative democracy. As with direct democracy, everyone has the opportunity to vote on every issue. However, unlike direct democracy, you also have the choice to delegate your vote to someone else. You can even choose to delegate your votes on different issues to different people. For example, on environmental issues, you might choose to delegate your vote to your favourite environmentalist. Whereas on issues concerning government debt and taxation you might choose your father. This ability to delegate is recursive. It means that if your father, in turn, chooses to delegate his vote on financial issues to his favourite economist, your vote will also be delegated to that economist. If you're unhappy with your father's decision, you can take that power away from him/her, and either vote yourself or re-delegate to someone you deem more trustworthy. Under such a system, those with the most delegations become our representatives. But unlike representative democracy, they are held accountable in real-time. A system like this addresses the uninformed voters' issue that a direct democracy creates by allowing these voters allot their votes to experts. It also addresses the corruption issues of representative democracy because citizens can rescind their vote from someone instantly, forcing delegates to vote in the best interest of their constituents. It is the best of both worlds that truly gives the power of influence to the voters. ( Source ) This sounds almost too good to be true. A fair, transparent, and corruption-free government! Why haven't we implemented this before? Since there is no central government under this form of democracy, we need to figure out how to allow citizens to vote in a secure, private, and decentralized way. It turns out this is a pretty hard problem to solve. It has actually been impossible to solve. Until now. This is the first time in our history that technology exists to turn this dream into reality. Of course, we're talking about public blockchains. Right now, we're in the experimentation phase. There are still some hard challenges that need to be overcome. The three main challenges revolve around scalability , privacy , and Sybil attacks . Scalability is important because we need millions of people to be able to use these systems. Privacy is important because it ensures voters can't be discriminated against for the decisions they make. It also makes it harder for them to be bribed/coerced into voting for something they don't believe in. But perhaps the hardest challenge is to ensure that one person is not able to vote multiple times (what's known in the jargon as a Sybil attack). The key to solving the last two challenges is a voting protocol that requires basic verification and reputation for each user whilst protecting their pseudonymous identity. In other words, a voting protocol with a built-in decentralized identity system. Put another way, decentralized identity is the big unlock that's needed to turn liquid democracy into a reality. P.S. It turns out that solving the privacy problem helps solve the scalability problem too, but we won't get into that here.","title":"Liquid Democracy"},{"location":"circom-snarkjs/","text":"Circom 2.0 Circuit Compiler for ZK Proving Systems Circom is a novel domain-specific language for defining arithmetic circuits and its associated compiler written in Rust language. Our open-source library of templates called CircomLib is publicly available to practitioners and developers. The library contains multiple circuit templates that have been reviewed and proven to work by our research team. The implementations of the proving systems are also available in our libraries: SnarkJS , written in Javascript and Pure Web Assembly; wasmsnark written in native Web Assembly; and rapidSnark written in C++ and Intel Assembly. Our team is currently working on the development of RapidPLONK and a run-time architecture for ARM processors. This way, Circom aims to provide developers with a holistic framework to construct arithmetic circuits through an easy-to-use interface and abstract the complexity of the proving mechanisms. ==> circom","title":"Circom / snarkjs"},{"location":"circom-snarkjs/#circom-20","text":"Circuit Compiler for ZK Proving Systems Circom is a novel domain-specific language for defining arithmetic circuits and its associated compiler written in Rust language. Our open-source library of templates called CircomLib is publicly available to practitioners and developers. The library contains multiple circuit templates that have been reviewed and proven to work by our research team. The implementations of the proving systems are also available in our libraries: SnarkJS , written in Javascript and Pure Web Assembly; wasmsnark written in native Web Assembly; and rapidSnark written in C++ and Intel Assembly. Our team is currently working on the development of RapidPLONK and a run-time architecture for ARM processors. This way, Circom aims to provide developers with a holistic framework to construct arithmetic circuits through an easy-to-use interface and abstract the complexity of the proving mechanisms.","title":"Circom 2.0"},{"location":"circom-snarkjs/#circom","text":"","title":"==&gt; circom"},{"location":"contracts/state/","text":"State Contract State.sol - Github The state contract stores the state of each identity operating within Polygon ID. Each identity has an identifier and an identity state associated to it. Each identifier and the corresponding identity state are stored inside the identities mapping. An identity gets updated by executing the state transition function . The State contract verifier the proof on-chain via its transitState function. The State contract provides a timestamp of the changes that occur inside an identity state. No personal information (such as claims) is stored on-chain nor it is inferrable from the information stored on-chain. Note that the actual proof verification is executed by calling the verifyProof function inside the verifier.sol . The verifier.sol contract is automatically generated using circom and can be used as a standalone contract to verify the proof. State.sol implements further logic once the proof is verified (such as updating the identity state). State contract addresses: Mumbai: 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 Polygon Mainnet: 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8","title":"State Contract"},{"location":"contracts/state/#state-contract","text":"State.sol - Github The state contract stores the state of each identity operating within Polygon ID. Each identity has an identifier and an identity state associated to it. Each identifier and the corresponding identity state are stored inside the identities mapping. An identity gets updated by executing the state transition function . The State contract verifier the proof on-chain via its transitState function. The State contract provides a timestamp of the changes that occur inside an identity state. No personal information (such as claims) is stored on-chain nor it is inferrable from the information stored on-chain. Note that the actual proof verification is executed by calling the verifyProof function inside the verifier.sol . The verifier.sol contract is automatically generated using circom and can be used as a standalone contract to verify the proof. State.sol implements further logic once the proof is verified (such as updating the identity state). State contract addresses: Mumbai: 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 Polygon Mainnet: 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8","title":"State Contract"},{"location":"getting-started/babyjubjub/","text":"Baby Jubjub Key Pair In Iden3 Protocol the public and private key pair is used to manage an identity and to authenticate in the name of an identity. In particular, Baby Jubjub is the elliptic curve used in Iden3. This curve is designed to work efficiently with zkSNARKs. 1. Initiate a Go Module go mod init example/iden3-tutorial 2. Update the required dependencies. go get github.com/iden3/go-iden3-crypto/babyjub 3. Generate a baby jubjub public key. package main import ( \"fmt\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // BabyJubJub key func main() { // generate babyJubjub private key randomly babyJubjubPrivKey := babyjub.NewRandPrivKey() // generate public key from private key babyJubjubPubKey := babyJubjubPrivKey.Public() // print public key fmt.Println(babyJubjubPubKey) } Here is an example of a public key generated using Baby Jubjub: 500d43e1c3daa864995a9615b6f9e3a4fd0af018548c583773b6e422b14201a3 The executable code can be found here","title":"Baby Jubjub Keypair"},{"location":"getting-started/babyjubjub/#baby-jubjub-key-pair","text":"In Iden3 Protocol the public and private key pair is used to manage an identity and to authenticate in the name of an identity. In particular, Baby Jubjub is the elliptic curve used in Iden3. This curve is designed to work efficiently with zkSNARKs. 1. Initiate a Go Module go mod init example/iden3-tutorial 2. Update the required dependencies. go get github.com/iden3/go-iden3-crypto/babyjub 3. Generate a baby jubjub public key. package main import ( \"fmt\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // BabyJubJub key func main() { // generate babyJubjub private key randomly babyJubjubPrivKey := babyjub.NewRandPrivKey() // generate public key from private key babyJubjubPubKey := babyJubjubPrivKey.Public() // print public key fmt.Println(babyJubjubPubKey) } Here is an example of a public key generated using Baby Jubjub: 500d43e1c3daa864995a9615b6f9e3a4fd0af018548c583773b6e422b14201a3 The executable code can be found here","title":"Baby Jubjub Key Pair"},{"location":"getting-started/getting-started/","text":"Introduction The first part of the tutorial walks you through the core components of Iden3 protocol necessary to initiate an identity and design claims: Baby Jubjub Keypair Sparse Merkle Tree Claim Identity Having understood the primitives you will be then able to start issuing claims . The tutorial follows a cascade strucuture: each step relies on the data and code snippets generated in the previous ones. The full executable code can be found here Iden3 Go Core Libraries Go Iden3 core - Identity core primitives Go Iden3 crypto - Implementation of Poseidon hash and Baby JubJub Elliptic curve Go Merkletree sql - Implementation of Sparse Merkle tree Go circuits - A library for transforming the go-core primitives to json inputs for identity circuits Other useful resources Circom2 - A compiler written in Rust for compiling circuits written in the Circom language SnarkJS - An npm package that contains APIs to generate and validate zk proofs generated by Circom GoLang Intro - Recommended if you are not proficient with GoLang","title":"Introduction"},{"location":"getting-started/getting-started/#introduction","text":"The first part of the tutorial walks you through the core components of Iden3 protocol necessary to initiate an identity and design claims: Baby Jubjub Keypair Sparse Merkle Tree Claim Identity Having understood the primitives you will be then able to start issuing claims . The tutorial follows a cascade strucuture: each step relies on the data and code snippets generated in the previous ones. The full executable code can be found here","title":"Introduction"},{"location":"getting-started/getting-started/#iden3-go-core-libraries","text":"Go Iden3 core - Identity core primitives Go Iden3 crypto - Implementation of Poseidon hash and Baby JubJub Elliptic curve Go Merkletree sql - Implementation of Sparse Merkle tree Go circuits - A library for transforming the go-core primitives to json inputs for identity circuits","title":"Iden3 Go Core Libraries"},{"location":"getting-started/getting-started/#other-useful-resources","text":"Circom2 - A compiler written in Rust for compiling circuits written in the Circom language SnarkJS - An npm package that contains APIs to generate and validate zk proofs generated by Circom GoLang Intro - Recommended if you are not proficient with GoLang","title":"Other useful resources"},{"location":"getting-started/issue-claim-overview/","text":"Overview In the last section, you have initiated an identity and created different types of claims. As of now, the claims haven\u2019t been published or issued in any way. The goal of this section is to issue claims so that the receiver can start using them within other applications. Starting from the same core claim there are two ways of issuing it: via Signature or via Merkle tree. Via Signature The claim gets signed by the issuer using her private key. The proof of issuance is the signature itself. This action doesn\u2019t modify the identity state of the issuer, so there\u2019s no on-chain transaction involved. Via Merkle tree The claim gets added to the issuer\u2019s Claims Tree . This action modifies the structure of the Merkle Tree and, therefore, the state has to be updated with the new Merkle root. The state transition involves an on-chain transaction. In this case, the proof of issuance is the membership of the claim iself inside the issuer\u2019s Claims Tree. Similarities and Differences Both approaches guarantee that the claim is tamper-resistant. The private zk-based verification of the claim is equally guaranteed in both cases. The process of updating the on-chain state (in the case of Merkle Tree (MT)) may take around 10/20 seconds, so the claim could not be immediately available to use for the user. Instead, with Signature (S), the claim is immediately ready for use. The biggest advantage of MT approach is that it offers timestamp proof of an identity state: a user could always prove the existence of a claim at a specific point in time according to the block number when it was added to the issuer tree. Naturally, this comes at a cost: the gas fees needed to update the state (458,228 gas used inside the transaction). No on-chain transactions take place in the case of S. A further element of difference regards the uniqueness of the claim: in the MT case, there couldn\u2019t be two claims with the same index Claim Data Structure . This is guaranteed by the characteristic of Sparse Merkle Tree . With S, an issuer could sign as many claims they want with the same index. Let\u2019s consider an example: a passport issued as a claim. This claim contains the identifier of the passport owner inside its index. MT approach provides a cryptographic guarantee that the issuer cannot duplicate the passport by issuing a claim with the same identifier. S doesn\u2019t. Note: This section describes the claim issuance on a protocol level. The way in which issuers and users\u2019 wallets communicate and transfer claims is defined on a platform level. This will be the subject of Polygon ID light issuer tutorial coming out this Autumn.","title":"Overview"},{"location":"getting-started/issue-claim-overview/#overview","text":"In the last section, you have initiated an identity and created different types of claims. As of now, the claims haven\u2019t been published or issued in any way. The goal of this section is to issue claims so that the receiver can start using them within other applications. Starting from the same core claim there are two ways of issuing it: via Signature or via Merkle tree.","title":"Overview"},{"location":"getting-started/issue-claim-overview/#via-signature","text":"The claim gets signed by the issuer using her private key. The proof of issuance is the signature itself. This action doesn\u2019t modify the identity state of the issuer, so there\u2019s no on-chain transaction involved.","title":"Via Signature"},{"location":"getting-started/issue-claim-overview/#via-merkle-tree","text":"The claim gets added to the issuer\u2019s Claims Tree . This action modifies the structure of the Merkle Tree and, therefore, the state has to be updated with the new Merkle root. The state transition involves an on-chain transaction. In this case, the proof of issuance is the membership of the claim iself inside the issuer\u2019s Claims Tree.","title":"Via Merkle tree"},{"location":"getting-started/issue-claim-overview/#similarities-and-differences","text":"Both approaches guarantee that the claim is tamper-resistant. The private zk-based verification of the claim is equally guaranteed in both cases. The process of updating the on-chain state (in the case of Merkle Tree (MT)) may take around 10/20 seconds, so the claim could not be immediately available to use for the user. Instead, with Signature (S), the claim is immediately ready for use. The biggest advantage of MT approach is that it offers timestamp proof of an identity state: a user could always prove the existence of a claim at a specific point in time according to the block number when it was added to the issuer tree. Naturally, this comes at a cost: the gas fees needed to update the state (458,228 gas used inside the transaction). No on-chain transactions take place in the case of S. A further element of difference regards the uniqueness of the claim: in the MT case, there couldn\u2019t be two claims with the same index Claim Data Structure . This is guaranteed by the characteristic of Sparse Merkle Tree . With S, an issuer could sign as many claims they want with the same index. Let\u2019s consider an example: a passport issued as a claim. This claim contains the identifier of the passport owner inside its index. MT approach provides a cryptographic guarantee that the issuer cannot duplicate the passport by issuing a claim with the same identifier. S doesn\u2019t. Note: This section describes the claim issuance on a protocol level. The way in which issuers and users\u2019 wallets communicate and transfer claims is defined on a platform level. This will be the subject of Polygon ID light issuer tutorial coming out this Autumn.","title":"Similarities and Differences"},{"location":"getting-started/json-ld-credential/","text":"JSON-LD Credentials JSON-LD Credential and Claim A Claim is the core data structure used by Iden3 to represent information. A claim by itself doesn't contain enough meaningful information to be read, understood and consumed (e.g. by the wallet). For example it doesn't tell anything about the meaning of values stored inside the data slots. The JSON-LD credential is able to pack the information contained in a claim in a more human-readable way. Furthermore, a JSON-LD credential does not only contain the claim itself but other proofs needed for the subject of the claim needs to consume the claim with other Verifiers. Let's anaylise what is a JSON-LD Credential with a practical example. The first tab contains a claim attesting to someone's date of birth (this is the same claim generated in the Generic Claim Section ). The second tab contains the corresponding JSON-LD Credential of type KYCAgeCredential . === \"Core Claim Format\" ```go Index: { \"3613283249068442770038516118105710406958\", // Claim Schema hash \"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim \"19960424\", // First index data slot stores the date of birth \"1\" // Second index data slot stores the document type } Value: { \"227737944108667786680629310498\", // Revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } ``` === \"JSON-LD Credential\" ``` json { \"id\": \"eca80230-6ed1-4251-8fe9-3c0204ba10ba\", \"@context\": [ \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential.json-ld\", \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\" ], \"@type\": [ \"Iden3Credential\" ], \"expiration\": \"2361-03-22T00:44:48+05:30\", \"updatable\": false, \"version\": 0, \"rev_nonce\": 1909830690, \"credentialSubject\": { \"birthday\": 19960424, \"documentType\": 1, \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\", \"type\": \"KYCAgeCredential\" }, \"credentialStatus\": { \"id\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\", \"type\": \"SparseMerkleTreeProof\" }, \"subject_position\": \"index\", \"credentialSchema\": { \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" }, \"proof\": [ { \"@type\": \"BJJSignature2021\", \"issuer_data\": { \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\", \"state\": { \"claims_tree_root\": \"ea5774fac8d72478d4db8a57a46193597bb61475fc9e72bdc74a0ce35aa85518\", \"value\": \"5ccc30d5d0360170a29188d5a907381098801a1ab09003493d9833fa4d95271f\" }, \"auth_claim\": [ \"304427537360709784173770334266246861770\", \"0\", \"6610201945487752676983171932113332232608162355365546060896064454271869708127\", \"11380100573862532536254569563965305187461805636461289256869908267462627351172\", \"0\", \"0\", \"0\", \"0\" ], \"mtp\": { \"existence\": true, \"siblings\": [] }, \"revocation_status\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\" }, \"signature\": \"5e1356754a061c9f691496a4b4bd4cab5d1d74eb835ef7575fc6b2c1e8b4311dab9e2b544f9c3f4701324b1e0b3a8c09de22425de9038c2a08f98f6963f17102\" } ] } ``` The core claim (1st tab) contains a limited set of information such as the schema hash, the identity subject of the claim, the data slots stored inside the claim (in this case the date of birth) and the revocation nonce of the claim. It's worth noting that the claim by itself doesn't say anything about the meaning of this content. How can someone infer that that value refers to a birthday? Furthermore the claim doesn't reveal information about the issuer, nor whether it has been revoked or not. All these set of extended information about a claim are included in the JSON-LD format in order to allow other parties to consume and understand the content of a claim. In particular the first part of the JSON-LD Credential contains the details of the claim: id namely the identifier of the credential itself context , as per JSON-LD spec is used to establish a description of the common terms that we will be using such as \"expiration\", \"updatable\" .... In particular the first one is standard for iden3 credential vocabulary while the second is specific to this type of claim. type defines the type of the credential itself, when dealing with iden3 claim the credential should always be named Iden3Credential expriation which is a field contained in the claim in v_0(specifically, the hash of this value is contained in the claim) updatable which is a field contained in the claim in i_0 version which is a field contained in the claim in i_0 rev_nonce which is a field contained in the claim in v_0 credentialSubject which contains all the details about the subject of the claim and the information contained in the claim regarding the subject credentialStatus which contains a url to fetch the revocation status of the claim subject_position indicates whether the identifier of the subject of the claim should be stored inside index data slot (i_1) or value data slot (v_1) credentialSchema defines the Schema of the claim itself The second part ofthe JSON-LD Credential contains a cryptographic proof that the credentials was issued by a specific issuer: @type indicates the way the proof was generated. It can be either \"BJJSignature2021\" or \"Iden3SparseMerkleProof\" issuer_data contains all the data related to the issuer of the claim. Including its identifier ( id ), its identity state value at the time of the issuance ( id ), its Auth Claim ( auth_claim ), the merkle tree proof that the Auth Claim belongs to the Claims Tree at the time of the issuance ( mtp ) and, lastly, a url to fetch the revocation status of the issuer's auth claim ( revocation_status ) signature contains the signed claim generated using the issuer's private key In this case the claim was issued by signature, in the case of claim of Merkle Tree Type the proof array would also contain a second value, namely the Iden3SparseMerkleProof of inclusion of the issued claim inside the issuer's Claims Tree The subject of the claim will store the JSON-LD format credential inside their wallet. Starting from the details contained inside the Credential he/she will be able to generate zk proofs and present it to Verifiers. [] Why we need that JSON-LD Credential? [] How am I able to get from the credential to core-claim? Is it gonna match? Is it also able to parse revocation nonce etcetera? [] Does the parsing also work in reverse? From claim to VC? [] What is signature ? - [] Add part to explain how to parse the VC into a core claim","title":"JSON-LD Credentials"},{"location":"getting-started/json-ld-credential/#json-ld-credentials","text":"","title":"JSON-LD Credentials"},{"location":"getting-started/json-ld-credential/#json-ld-credential-and-claim","text":"A Claim is the core data structure used by Iden3 to represent information. A claim by itself doesn't contain enough meaningful information to be read, understood and consumed (e.g. by the wallet). For example it doesn't tell anything about the meaning of values stored inside the data slots. The JSON-LD credential is able to pack the information contained in a claim in a more human-readable way. Furthermore, a JSON-LD credential does not only contain the claim itself but other proofs needed for the subject of the claim needs to consume the claim with other Verifiers. Let's anaylise what is a JSON-LD Credential with a practical example. The first tab contains a claim attesting to someone's date of birth (this is the same claim generated in the Generic Claim Section ). The second tab contains the corresponding JSON-LD Credential of type KYCAgeCredential . === \"Core Claim Format\" ```go Index: { \"3613283249068442770038516118105710406958\", // Claim Schema hash \"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim \"19960424\", // First index data slot stores the date of birth \"1\" // Second index data slot stores the document type } Value: { \"227737944108667786680629310498\", // Revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } ``` === \"JSON-LD Credential\" ``` json { \"id\": \"eca80230-6ed1-4251-8fe9-3c0204ba10ba\", \"@context\": [ \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential.json-ld\", \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\" ], \"@type\": [ \"Iden3Credential\" ], \"expiration\": \"2361-03-22T00:44:48+05:30\", \"updatable\": false, \"version\": 0, \"rev_nonce\": 1909830690, \"credentialSubject\": { \"birthday\": 19960424, \"documentType\": 1, \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\", \"type\": \"KYCAgeCredential\" }, \"credentialStatus\": { \"id\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\", \"type\": \"SparseMerkleTreeProof\" }, \"subject_position\": \"index\", \"credentialSchema\": { \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" }, \"proof\": [ { \"@type\": \"BJJSignature2021\", \"issuer_data\": { \"id\": \"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\", \"state\": { \"claims_tree_root\": \"ea5774fac8d72478d4db8a57a46193597bb61475fc9e72bdc74a0ce35aa85518\", \"value\": \"5ccc30d5d0360170a29188d5a907381098801a1ab09003493d9833fa4d95271f\" }, \"auth_claim\": [ \"304427537360709784173770334266246861770\", \"0\", \"6610201945487752676983171932113332232608162355365546060896064454271869708127\", \"11380100573862532536254569563965305187461805636461289256869908267462627351172\", \"0\", \"0\", \"0\", \"0\" ], \"mtp\": { \"existence\": true, \"siblings\": [] }, \"revocation_status\": \"https://fe03-49-248-235-75.in.ngrok.io/api/v1/claims/revocation/status/1909830690\" }, \"signature\": \"5e1356754a061c9f691496a4b4bd4cab5d1d74eb835ef7575fc6b2c1e8b4311dab9e2b544f9c3f4701324b1e0b3a8c09de22425de9038c2a08f98f6963f17102\" } ] } ``` The core claim (1st tab) contains a limited set of information such as the schema hash, the identity subject of the claim, the data slots stored inside the claim (in this case the date of birth) and the revocation nonce of the claim. It's worth noting that the claim by itself doesn't say anything about the meaning of this content. How can someone infer that that value refers to a birthday? Furthermore the claim doesn't reveal information about the issuer, nor whether it has been revoked or not. All these set of extended information about a claim are included in the JSON-LD format in order to allow other parties to consume and understand the content of a claim. In particular the first part of the JSON-LD Credential contains the details of the claim: id namely the identifier of the credential itself context , as per JSON-LD spec is used to establish a description of the common terms that we will be using such as \"expiration\", \"updatable\" .... In particular the first one is standard for iden3 credential vocabulary while the second is specific to this type of claim. type defines the type of the credential itself, when dealing with iden3 claim the credential should always be named Iden3Credential expriation which is a field contained in the claim in v_0(specifically, the hash of this value is contained in the claim) updatable which is a field contained in the claim in i_0 version which is a field contained in the claim in i_0 rev_nonce which is a field contained in the claim in v_0 credentialSubject which contains all the details about the subject of the claim and the information contained in the claim regarding the subject credentialStatus which contains a url to fetch the revocation status of the claim subject_position indicates whether the identifier of the subject of the claim should be stored inside index data slot (i_1) or value data slot (v_1) credentialSchema defines the Schema of the claim itself The second part ofthe JSON-LD Credential contains a cryptographic proof that the credentials was issued by a specific issuer: @type indicates the way the proof was generated. It can be either \"BJJSignature2021\" or \"Iden3SparseMerkleProof\" issuer_data contains all the data related to the issuer of the claim. Including its identifier ( id ), its identity state value at the time of the issuance ( id ), its Auth Claim ( auth_claim ), the merkle tree proof that the Auth Claim belongs to the Claims Tree at the time of the issuance ( mtp ) and, lastly, a url to fetch the revocation status of the issuer's auth claim ( revocation_status ) signature contains the signed claim generated using the issuer's private key In this case the claim was issued by signature, in the case of claim of Merkle Tree Type the proof array would also contain a second value, namely the Iden3SparseMerkleProof of inclusion of the issued claim inside the issuer's Claims Tree The subject of the claim will store the JSON-LD format credential inside their wallet. Starting from the details contained inside the Credential he/she will be able to generate zk proofs and present it to Verifiers. [] Why we need that JSON-LD Credential? [] How am I able to get from the credential to core-claim? Is it gonna match? Is it also able to parse revocation nonce etcetera? [] Does the parsing also work in reverse? From claim to VC? [] What is signature ? - [] Add part to explain how to parse the VC into a core claim","title":"JSON-LD Credential and Claim"},{"location":"getting-started/mt/","text":"Sparse Merkle Tree A Merkle Tree or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The Merkle Trees used in Iden3 protocol are Sparse. In Sparse Merkle Trees each data block has an index associated to it that determines its position as leaf inside the tree. In addition to inheriting the tamper-resistance and proof-of-membership properties from standard merkle trees, a Sparse Merkle Tree has other features: The insert order of data blocks doesn't influence the final Merkle Tree Root. A data block A with index 1 and a data block B with index 4 will always occupy the same positions inside the tree despite the insert order Some leaves remain empty It's possible to prove that certain data is not included in the tree ( proof of non-membership ) A Sparse Merkle Tree is the core data structure used in Iden3 protocol to represent an identity. In particular, the leaves of a Sparse Merkle Tree are the claims issued by an identity. 1. Update the required dependencies. go get github.com/iden3/go-merkletree-sql 2. Design a Sparse Merkle Tree. package main import ( \"context\" \"fmt\" \"math/big\" merkletree \"github.com/iden3/go-merkletree-sql\" \"github.com/iden3/go-merkletree-sql/db/memory\" ) // Sparse MT func main() { ctx := context.Background() // Tree storage store := memory.NewMemoryStorage() // Generate a new MerkleTree with 32 levels mt, _ := merkletree.NewMerkleTree(ctx, store, 32) // Add a leaf to the tree with index 1 and value 10 index1 := big.NewInt(1) value1 := big.NewInt(10) mt.Add(ctx, index1, value1) // Add another leaf to the tree index2 := big.NewInt(2) value2 := big.NewInt(15) mt.Add(ctx, index2, value2) // Proof of membership of a leaf with index 1 proofExist, value, _ := mt.GenerateProof(ctx, index1, mt.Root()) fmt.Println(\"Proof of membership:\", proofExist.Existence) fmt.Println(\"Value corresponding to the queried index:\", value) // Proof of non-membership of a leaf with index 4 proofNotExist, _, _ := mt.GenerateProof(ctx, big.NewInt(4), mt.Root()) fmt.Println(\"Proof of membership:\", proofNotExist.Existence) } A data block inside the tree is represented by a index and a value . The index represents the position in the tree and it must be unique. The value represents the associated value stored in the tree. The GenerateProof method shown above allows verifying the membership of a leaf in the merkle tree starting from its root. The executable code can be found here","title":"Sparse Merkle Tree"},{"location":"getting-started/mt/#sparse-merkle-tree","text":"A Merkle Tree or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The Merkle Trees used in Iden3 protocol are Sparse. In Sparse Merkle Trees each data block has an index associated to it that determines its position as leaf inside the tree. In addition to inheriting the tamper-resistance and proof-of-membership properties from standard merkle trees, a Sparse Merkle Tree has other features: The insert order of data blocks doesn't influence the final Merkle Tree Root. A data block A with index 1 and a data block B with index 4 will always occupy the same positions inside the tree despite the insert order Some leaves remain empty It's possible to prove that certain data is not included in the tree ( proof of non-membership ) A Sparse Merkle Tree is the core data structure used in Iden3 protocol to represent an identity. In particular, the leaves of a Sparse Merkle Tree are the claims issued by an identity. 1. Update the required dependencies. go get github.com/iden3/go-merkletree-sql 2. Design a Sparse Merkle Tree. package main import ( \"context\" \"fmt\" \"math/big\" merkletree \"github.com/iden3/go-merkletree-sql\" \"github.com/iden3/go-merkletree-sql/db/memory\" ) // Sparse MT func main() { ctx := context.Background() // Tree storage store := memory.NewMemoryStorage() // Generate a new MerkleTree with 32 levels mt, _ := merkletree.NewMerkleTree(ctx, store, 32) // Add a leaf to the tree with index 1 and value 10 index1 := big.NewInt(1) value1 := big.NewInt(10) mt.Add(ctx, index1, value1) // Add another leaf to the tree index2 := big.NewInt(2) value2 := big.NewInt(15) mt.Add(ctx, index2, value2) // Proof of membership of a leaf with index 1 proofExist, value, _ := mt.GenerateProof(ctx, index1, mt.Root()) fmt.Println(\"Proof of membership:\", proofExist.Existence) fmt.Println(\"Value corresponding to the queried index:\", value) // Proof of non-membership of a leaf with index 4 proofNotExist, _, _ := mt.GenerateProof(ctx, big.NewInt(4), mt.Root()) fmt.Println(\"Proof of membership:\", proofNotExist.Existence) } A data block inside the tree is represented by a index and a value . The index represents the position in the tree and it must be unique. The value represents the associated value stored in the tree. The GenerateProof method shown above allows verifying the membership of a leaf in the merkle tree starting from its root. The executable code can be found here","title":"Sparse Merkle Tree"},{"location":"getting-started/claim/auth-claim/","text":"Key Authorization Claim The most important building block of an identity is the Key Authorization Claim. This claim stores user's Baby Jubjub public key. An Auth Claim must be included as a leaf inside the Identity Tree. All the actions performed by an Idenitity (such as claim issuance or revocation) require users to prove via a digital signature that they own the private key associated with the public key stored in the AuthClaim . 1. Define the claim schema. The auth schema is pre-defined and should always be the same when creating an AuthClaim . The schema hash is: ca938857241db9451ea329256b9c06e5 . According to the this schema, the X and Y coordinate of the Baby Jubjub public key must be stored, respectively, in the first and second index data slot. 2. Generate an AuthClaim. package main import ( \"encoding/json\" \"fmt\" \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // Create auth claim func main() { authSchemaHash, _ := core.NewSchemaHashFromHex(\"ca938857241db9451ea329256b9c06e5\") // Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation. revNonce := uint64(1) // Create auth Claim authClaim, _ := core.NewClaim(authSchemaHash, core.WithIndexDataInts(babyJubjubPubKey.X, babyJubjubPubKey.Y), core.WithRevocationNonce(revNonce)) authClaimToMarshal, _ := json.Marshal(authClaim) fmt.Println(string(authClaimToMarshal)) } Here is what the claim would look like: Claim: [\"304427537360709784173770334266246861770\",\"0\",\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",\"7208907202894542671711125895887320665787554014901011121180092863817137691080\",\"1\",\"0\",\"0\",\"0\"] Let us destructure the output: Index: { \"304427537360709784173770334266246861770\", // Schema hash \"0\", \"12360031355466667401641753955380306964012305931931806442343193949747916655340\", // X coordinate of the pubkey \"7208907202894542671711125895887320665787554014901011121180092863817137691080\" // Y coordinate of the pubkey } Value: { \"1\", // revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in position 1 of the Value contains the Revocation Nonce. This value will be used to revoke/invalidate an AuthClaim . More on that in the next section. The executable code can be found here","title":"Auth Claim"},{"location":"getting-started/claim/auth-claim/#key-authorization-claim","text":"The most important building block of an identity is the Key Authorization Claim. This claim stores user's Baby Jubjub public key. An Auth Claim must be included as a leaf inside the Identity Tree. All the actions performed by an Idenitity (such as claim issuance or revocation) require users to prove via a digital signature that they own the private key associated with the public key stored in the AuthClaim . 1. Define the claim schema. The auth schema is pre-defined and should always be the same when creating an AuthClaim . The schema hash is: ca938857241db9451ea329256b9c06e5 . According to the this schema, the X and Y coordinate of the Baby Jubjub public key must be stored, respectively, in the first and second index data slot. 2. Generate an AuthClaim. package main import ( \"encoding/json\" \"fmt\" \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // Create auth claim func main() { authSchemaHash, _ := core.NewSchemaHashFromHex(\"ca938857241db9451ea329256b9c06e5\") // Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation. revNonce := uint64(1) // Create auth Claim authClaim, _ := core.NewClaim(authSchemaHash, core.WithIndexDataInts(babyJubjubPubKey.X, babyJubjubPubKey.Y), core.WithRevocationNonce(revNonce)) authClaimToMarshal, _ := json.Marshal(authClaim) fmt.Println(string(authClaimToMarshal)) } Here is what the claim would look like: Claim: [\"304427537360709784173770334266246861770\",\"0\",\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",\"7208907202894542671711125895887320665787554014901011121180092863817137691080\",\"1\",\"0\",\"0\",\"0\"] Let us destructure the output: Index: { \"304427537360709784173770334266246861770\", // Schema hash \"0\", \"12360031355466667401641753955380306964012305931931806442343193949747916655340\", // X coordinate of the pubkey \"7208907202894542671711125895887320665787554014901011121180092863817137691080\" // Y coordinate of the pubkey } Value: { \"1\", // revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in position 1 of the Value contains the Revocation Nonce. This value will be used to revoke/invalidate an AuthClaim . More on that in the next section. The executable code can be found here","title":"Key Authorization Claim"},{"location":"getting-started/claim/claim-schema/","text":"Claim Schema The reusability of claims across platforms and services is guaranteed by Claim Schema consistency. Polygon ID use JSON-LD documents to represent Claim Schemas. As an issuer it is advised to check if any of the existing claim schemas can accomodate the type of information you are interested to issue. If not, here's the guide to create a new claim schema. Let us create a shared and reusable claim schema of type ProofOfDaoMembership . 1. Define the value to be included in the schema. The ProofOfDaoMembership claim should attest that a person covers a role inside a specific DAO. Information such as the identifier of the DAO or the identifier of the subject of the claim don't need to be encoded inside one of the four data slots allocated for claim information (i_2,i_3, v_2, v_3): The information about the specific DAO can be inferred from the claim issuer identifier The information about the individual subject of the claim is already stored in the i_1 or v_1 data slot of the claim A further information that must be included in the claim is the role of the individual inside a DAO. This will be the added inside one of the data slots (i_2,i_3,v_2,v_3). Remember that a claim can only store numeric data so each DAO role should be encoded as a number. 2. Decide where to store this information, should it be inside index data slots or value data slots? Claim's index determines its uniqueness inside the issuer's claims tree. There cannot be more than one claim with the same index. If it is decided to store the identifier of the subject of the claim inside i_1 and leave the other index data slots empty, it means that there can only be one claim issued to a specific identity inside the tree. In this case, the question is whether to store the information with type role inside i_2 or v_2. Storing the role inside i_2 means that the uniqueness inside the tree is determined by the combination \"person identifier + role\" Storing the role inside v_2 means that the uniqueness inside the tree is only determined the person identifier Considering the possibility that a DAO member covers more than one role, it makes more sense to store the role inside i_2. This choice allow the DAO to issue subsequent claims to the same individual attesting a different role. 3. Describe the vocabulary of the schema Create a markdown file in your repository to describe the vocabulary used in the claim. This should contain a description of the key type role and its possible values: # role Describes the role covered by an individual inside a specific DAO 1: Contributor 2: Guild Coordinator 3: Team Member 4. Create the JSON-LD document Add a file inside your repository with extension .json-ld and populate it. The @id key should contain the identifier of the Schema Type \"ProofOfDaoMembership\", in this case the unique url to the JSON-LD document. The proof-of-dao-vocab key should contain the url that describes the vocabulary of the claim schema. { \"@context\": [{ \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"ProofOfDaoMembership\": { \"@id\": \"https://raw.githubusercontent.com/iden3/tutorial-examples/main/claim-schema/proof-of-dao-membership.json-ld#ProofOfDaoMembership\", \"@context\": { \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"proof-of-dao-vocab\": \"https://github.com/iden3/tutorial-examples/blob/main/claim-schema/proof-of-dao.md#\", \"serialization\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\", \"type\": { \"@id\": \"proof-of-dao-vocab:role\", \"@type\": \"serialization:IndexDataSlotA\" }, } } }] } 5. Generate the schema hash The Schema Hash has to be added inside claim's index. The schema hash is generated by hashing together schemaBytes (the JSON-LD document in byte format) and credentialType (in this case \"ProofOfDaoMembership\"). In this case: package main import ( \"fmt\" \"os\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/keccak256\" ) func main() { schemaBytes, _ := os.ReadFile(\"./tutorial-examples/claim-schema/proof-of-dao-membership.json-ld\") var sHash core.SchemaHash h := keccak256.Hash(schemaBytes, []byte(\"ProofOfDaoMembership\")) copy(sHash[:], h[len(h)-16:]) sHashHex, _ := sHash.MarshalText() fmt.Println(string(sHashHex)) // 4f6bbcb133bfd4e9ebdf09b16a0816c8 } The executable code can be found here","title":"Claim Schema"},{"location":"getting-started/claim/claim-schema/#claim-schema","text":"The reusability of claims across platforms and services is guaranteed by Claim Schema consistency. Polygon ID use JSON-LD documents to represent Claim Schemas. As an issuer it is advised to check if any of the existing claim schemas can accomodate the type of information you are interested to issue. If not, here's the guide to create a new claim schema. Let us create a shared and reusable claim schema of type ProofOfDaoMembership . 1. Define the value to be included in the schema. The ProofOfDaoMembership claim should attest that a person covers a role inside a specific DAO. Information such as the identifier of the DAO or the identifier of the subject of the claim don't need to be encoded inside one of the four data slots allocated for claim information (i_2,i_3, v_2, v_3): The information about the specific DAO can be inferred from the claim issuer identifier The information about the individual subject of the claim is already stored in the i_1 or v_1 data slot of the claim A further information that must be included in the claim is the role of the individual inside a DAO. This will be the added inside one of the data slots (i_2,i_3,v_2,v_3). Remember that a claim can only store numeric data so each DAO role should be encoded as a number. 2. Decide where to store this information, should it be inside index data slots or value data slots? Claim's index determines its uniqueness inside the issuer's claims tree. There cannot be more than one claim with the same index. If it is decided to store the identifier of the subject of the claim inside i_1 and leave the other index data slots empty, it means that there can only be one claim issued to a specific identity inside the tree. In this case, the question is whether to store the information with type role inside i_2 or v_2. Storing the role inside i_2 means that the uniqueness inside the tree is determined by the combination \"person identifier + role\" Storing the role inside v_2 means that the uniqueness inside the tree is only determined the person identifier Considering the possibility that a DAO member covers more than one role, it makes more sense to store the role inside i_2. This choice allow the DAO to issue subsequent claims to the same individual attesting a different role. 3. Describe the vocabulary of the schema Create a markdown file in your repository to describe the vocabulary used in the claim. This should contain a description of the key type role and its possible values: # role Describes the role covered by an individual inside a specific DAO 1: Contributor 2: Guild Coordinator 3: Team Member 4. Create the JSON-LD document Add a file inside your repository with extension .json-ld and populate it. The @id key should contain the identifier of the Schema Type \"ProofOfDaoMembership\", in this case the unique url to the JSON-LD document. The proof-of-dao-vocab key should contain the url that describes the vocabulary of the claim schema. { \"@context\": [{ \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"ProofOfDaoMembership\": { \"@id\": \"https://raw.githubusercontent.com/iden3/tutorial-examples/main/claim-schema/proof-of-dao-membership.json-ld#ProofOfDaoMembership\", \"@context\": { \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"proof-of-dao-vocab\": \"https://github.com/iden3/tutorial-examples/blob/main/claim-schema/proof-of-dao.md#\", \"serialization\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\", \"type\": { \"@id\": \"proof-of-dao-vocab:role\", \"@type\": \"serialization:IndexDataSlotA\" }, } } }] } 5. Generate the schema hash The Schema Hash has to be added inside claim's index. The schema hash is generated by hashing together schemaBytes (the JSON-LD document in byte format) and credentialType (in this case \"ProofOfDaoMembership\"). In this case: package main import ( \"fmt\" \"os\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/keccak256\" ) func main() { schemaBytes, _ := os.ReadFile(\"./tutorial-examples/claim-schema/proof-of-dao-membership.json-ld\") var sHash core.SchemaHash h := keccak256.Hash(schemaBytes, []byte(\"ProofOfDaoMembership\")) copy(sHash[:], h[len(h)-16:]) sHashHex, _ := sHash.MarshalText() fmt.Println(string(sHashHex)) // 4f6bbcb133bfd4e9ebdf09b16a0816c8 } The executable code can be found here","title":"Claim Schema"},{"location":"getting-started/claim/generic-claim/","text":"Generic Claim A Claim is a statement made by one identity about another identity or about itself. In general, claim is a flexible and modular data primitive that can be used to represent any identity-related information. Claims can be viewed as Soul Bound Tokens (SBTs) on steroids. Similar to SBTs, the ownership is cryptographically guaranteed allowing control and reusability across platforms. Differently to SBTs, claims live off-chain ensuring users privacy over their Personal Identifiable Information. 1. Update the required dependencies. go get github.com/iden3/go-iden3-core 2. Define the claim schema . A claim schema defines how a set of data must be stored inside a claim. In this example, we will use a schema called KYCAgeCredential . According to this schema the birthday is stored in the first index slot of the claim data structure , while the documentType is stored in the second data slot. The hash of the schema is generated from the content of the schema document following the Claim Schema Generation Rules . For our example, the hash of the schema is: 2e2d1c11ad3e500de68d7ce16a0a559e 3. Create a generic claim. package main import ( \"encoding/json\" \"fmt\" \"math/big\" \"time\" core \"github.com/iden3/go-iden3-core\" ) // create basic claim func main() { // set claim expriation date to 2361-03-22T00:44:48+05:30 t := time.Date(2361, 3, 22, 0, 44, 48, 0, time.UTC) // set schema ageSchema, _ := core.NewSchemaHashFromHex (\"2e2d1c11ad3e500de68d7ce16a0a559e\") // define data slots birthday := big.NewInt(19960424) documentType := big.NewInt(1) // set revocation nonce revocationNonce := uint64(1909830690) // set ID of the claim subject id, _ := core.IDFromString(\"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\") // create claim claim, _ := core.NewClaim(ageSchema, core.WithExpirationDate(t), core.WithRevocationNonce(revocationNonce), core.WithIndexID(id), core.WithIndexDataInts(birthday, documentType)) // transform claim from bytes array to json claimToMarshal, _ := json.Marshal(claim) fmt.Println(string(claimToMarshal)) } Here is what the claim would look like: [\"3613283249068442770038516118105710406958\",\"86645363564555144061174553487309804257148595648980197130928167920533372928\",\"19960424\",\"1\",\"227737944108667786680629310498\",\"0\",\"0\",\"0\"] In particular, the first 4 values of the claim represent the Index part of the claim while the last 4 represent the Value . Index: { \"3613283249068442770038516118105710406958\", // Claim Schema hash \"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim \"19960424\", // First index data slot stores the date of birth \"1\" // Second index data slot stores the document type } Value: { \"227737944108667786680629310498\", // Revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in the first position of the Index contains a reference to the schemahash of the claim. As defined in the KYCAgeCredential schema , the value birthday must be stored in the first index data slot while the second index stores the documentType. Other schemas may provide different rules on where to store the data. The executable code can be found here","title":"Generic Claim"},{"location":"getting-started/claim/generic-claim/#generic-claim","text":"A Claim is a statement made by one identity about another identity or about itself. In general, claim is a flexible and modular data primitive that can be used to represent any identity-related information. Claims can be viewed as Soul Bound Tokens (SBTs) on steroids. Similar to SBTs, the ownership is cryptographically guaranteed allowing control and reusability across platforms. Differently to SBTs, claims live off-chain ensuring users privacy over their Personal Identifiable Information. 1. Update the required dependencies. go get github.com/iden3/go-iden3-core 2. Define the claim schema . A claim schema defines how a set of data must be stored inside a claim. In this example, we will use a schema called KYCAgeCredential . According to this schema the birthday is stored in the first index slot of the claim data structure , while the documentType is stored in the second data slot. The hash of the schema is generated from the content of the schema document following the Claim Schema Generation Rules . For our example, the hash of the schema is: 2e2d1c11ad3e500de68d7ce16a0a559e 3. Create a generic claim. package main import ( \"encoding/json\" \"fmt\" \"math/big\" \"time\" core \"github.com/iden3/go-iden3-core\" ) // create basic claim func main() { // set claim expriation date to 2361-03-22T00:44:48+05:30 t := time.Date(2361, 3, 22, 0, 44, 48, 0, time.UTC) // set schema ageSchema, _ := core.NewSchemaHashFromHex (\"2e2d1c11ad3e500de68d7ce16a0a559e\") // define data slots birthday := big.NewInt(19960424) documentType := big.NewInt(1) // set revocation nonce revocationNonce := uint64(1909830690) // set ID of the claim subject id, _ := core.IDFromString(\"113TCVw5KMeMp99Qdvub9Mssfz7krL9jWNvbdB7Fd2\") // create claim claim, _ := core.NewClaim(ageSchema, core.WithExpirationDate(t), core.WithRevocationNonce(revocationNonce), core.WithIndexID(id), core.WithIndexDataInts(birthday, documentType)) // transform claim from bytes array to json claimToMarshal, _ := json.Marshal(claim) fmt.Println(string(claimToMarshal)) } Here is what the claim would look like: [\"3613283249068442770038516118105710406958\",\"86645363564555144061174553487309804257148595648980197130928167920533372928\",\"19960424\",\"1\",\"227737944108667786680629310498\",\"0\",\"0\",\"0\"] In particular, the first 4 values of the claim represent the Index part of the claim while the last 4 represent the Value . Index: { \"3613283249068442770038516118105710406958\", // Claim Schema hash \"86645363564555144061174553487309804257148595648980197130928167920533372928\", // ID Subject of the claim \"19960424\", // First index data slot stores the date of birth \"1\" // Second index data slot stores the document type } Value: { \"227737944108667786680629310498\", // Revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in the first position of the Index contains a reference to the schemahash of the claim. As defined in the KYCAgeCredential schema , the value birthday must be stored in the first index data slot while the second index stores the documentType. Other schemas may provide different rules on where to store the data. The executable code can be found here","title":"Generic Claim"},{"location":"getting-started/identity/identifier/","text":"Identifier Each identity has a unique identifier. ID is: Permanent: it remains the same for the entire existence of an identity. Unique: No two identities can have the same ID. The ID is deterministically calculated from the Genesis State. Retrieve the Identifier ID package main import ( \"fmt\" core \"github.com/iden3/go-iden3-core\" ) // Retrieve ID func main() { id, _ := core.IdGenesisFromIdenState(core.TypeDefault, state.BigInt()) fmt.Println(\"ID:\", id) } Here is what the output would look like: ID: 11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA Hereafter, this identity is represented as a mapping: ID => IdS . This gets published, together with all other identities, inside the identities mapping, which is part of the State.sol contract . While the ID remains constant, the Identity State will get updated as soon as the identity adds or revokes claims in its trees. No Personal Identifiable Information (PPI) is stored on-chain. From the IdS is impossible to retrieve any information (represented as claim) stored inside the Identity Claims Tree The Identity State hasn't been published on-chain yet as claims haven't been issued yet. This is the subject of the next section. The executable code can be found here","title":"Identifier"},{"location":"getting-started/identity/identifier/#identifier","text":"Each identity has a unique identifier. ID is: Permanent: it remains the same for the entire existence of an identity. Unique: No two identities can have the same ID. The ID is deterministically calculated from the Genesis State. Retrieve the Identifier ID package main import ( \"fmt\" core \"github.com/iden3/go-iden3-core\" ) // Retrieve ID func main() { id, _ := core.IdGenesisFromIdenState(core.TypeDefault, state.BigInt()) fmt.Println(\"ID:\", id) } Here is what the output would look like: ID: 11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA Hereafter, this identity is represented as a mapping: ID => IdS . This gets published, together with all other identities, inside the identities mapping, which is part of the State.sol contract . While the ID remains constant, the Identity State will get updated as soon as the identity adds or revokes claims in its trees. No Personal Identifiable Information (PPI) is stored on-chain. From the IdS is impossible to retrieve any information (represented as claim) stored inside the Identity Claims Tree The Identity State hasn't been published on-chain yet as claims haven't been issued yet. This is the subject of the next section. The executable code can be found here","title":"Identifier"},{"location":"getting-started/identity/identity-state/","text":"Identity State An Identity State IdS is represented by the hash of the roots of these three merkle trees. IdS = H(ClR || ReR || RoR) where: H : Hashing Function ClR : Claims Tree Root ReR : Revocation Tree Root RoR : Roots Tree Root The identity state gets stored on-chain and represents the status of an identity at a certain point in time. Identity State Diagram Retrieve the Identity State IdS package main import ( \"fmt\" \"github.com/iden3/go-merkletree-sql\" ) // Retrieve Identity State func main() { // calculate Identity State as a hash of the three roots state, _ := merkletree.HashElems( clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) fmt.Println(\"Identity State:\", state) } Here is what the output would look like: Identity State: 20698226269617404048572275736120991936409000313072409404791246779211976957795 The very first identity state of an identity is defined as Genesis State Every verification inside Iden3 protocol is executed against the Identity State. For instance, to prove the validity of a specific claim issued by A to B (in case if the claims gets added to the claims tree): user B needs to produce a merkle proof of the existence of that claim inside user's A ClR user B needs to produce a merkle proof of non existence of the corresponding revocation nonce inside user's A ReT The executable code can be found here","title":"Identity State"},{"location":"getting-started/identity/identity-state/#identity-state","text":"An Identity State IdS is represented by the hash of the roots of these three merkle trees. IdS = H(ClR || ReR || RoR) where: H : Hashing Function ClR : Claims Tree Root ReR : Revocation Tree Root RoR : Roots Tree Root The identity state gets stored on-chain and represents the status of an identity at a certain point in time. Identity State Diagram Retrieve the Identity State IdS package main import ( \"fmt\" \"github.com/iden3/go-merkletree-sql\" ) // Retrieve Identity State func main() { // calculate Identity State as a hash of the three roots state, _ := merkletree.HashElems( clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) fmt.Println(\"Identity State:\", state) } Here is what the output would look like: Identity State: 20698226269617404048572275736120991936409000313072409404791246779211976957795 The very first identity state of an identity is defined as Genesis State Every verification inside Iden3 protocol is executed against the Identity State. For instance, to prove the validity of a specific claim issued by A to B (in case if the claims gets added to the claims tree): user B needs to produce a merkle proof of the existence of that claim inside user's A ClR user B needs to produce a merkle proof of non existence of the corresponding revocation nonce inside user's A ReT The executable code can be found here","title":"Identity State"},{"location":"getting-started/identity/identity-structure/","text":"Identity Structure Each identity consists of Three Sparse Merkle Trees : ClT : A Claims tree that contains the claims issued by that particular identity ReT : A Revocation tree that contains the revocation nonces of the claims that have been revoked by that particular identity RoT : A Roots tree that contains the history of the tree roots from the Claims tree Claims issued by an identity are added to the Claims tree (we'll see in a while why that's not always the case). The position of a claim inside the Sparse Merkle Tree is determined by the hash of the claim's Index while the value stored inside the leaf will be the hash of the claim's Value . An identity must issue at least one Auth Claim to operate properly. This is the first claim that is issued by an identity and that must be added to the ClT . Create identity trees and add authClaim package main import ( \"github.com/iden3/go-merkletree-sql\" ) // Generate the three identity trees func main() { // Create empty Claims tree clt, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Create empty Revocation tree ret, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Create empty Roots tree rot, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Get the Index and the Value of the authClaim hIndex, hValue, _ := authClaim.HiHv() // add auth claim to claims tree with value hValue at index hIndex clt.Add(ctx, hIndex, hValue) // print the roots fmt.Println(clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) } We just generated the three identity trees! For now, we only added a leaf correponding to the authClaim to the Claims tree ClT . The Revocation tree ReT and the RoT remain empty. In particular: The revocation tree gets updated whenever an identity decides to revoke a claim. For instance, if a user decides to rotate her keys, then she generates a key pair, creates a new authClaim with the public key from the key pair and adds the claim to the Claims Tree. Now the user can revoke the old public key, so she adds an entry to the Revocation Tree with the claim revocation nonce as an Index and zero as a Value. The Roots Tree gets updated whenever the Identity Claims Tree root gets updated. The executable code can be found here","title":"Identity Structure"},{"location":"getting-started/identity/identity-structure/#identity-structure","text":"Each identity consists of Three Sparse Merkle Trees : ClT : A Claims tree that contains the claims issued by that particular identity ReT : A Revocation tree that contains the revocation nonces of the claims that have been revoked by that particular identity RoT : A Roots tree that contains the history of the tree roots from the Claims tree Claims issued by an identity are added to the Claims tree (we'll see in a while why that's not always the case). The position of a claim inside the Sparse Merkle Tree is determined by the hash of the claim's Index while the value stored inside the leaf will be the hash of the claim's Value . An identity must issue at least one Auth Claim to operate properly. This is the first claim that is issued by an identity and that must be added to the ClT . Create identity trees and add authClaim package main import ( \"github.com/iden3/go-merkletree-sql\" ) // Generate the three identity trees func main() { // Create empty Claims tree clt, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Create empty Revocation tree ret, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Create empty Roots tree rot, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), 32) // Get the Index and the Value of the authClaim hIndex, hValue, _ := authClaim.HiHv() // add auth claim to claims tree with value hValue at index hIndex clt.Add(ctx, hIndex, hValue) // print the roots fmt.Println(clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) } We just generated the three identity trees! For now, we only added a leaf correponding to the authClaim to the Claims tree ClT . The Revocation tree ReT and the RoT remain empty. In particular: The revocation tree gets updated whenever an identity decides to revoke a claim. For instance, if a user decides to rotate her keys, then she generates a key pair, creates a new authClaim with the public key from the key pair and adds the claim to the Claims Tree. Now the user can revoke the old public key, so she adds an entry to the Revocation Tree with the claim revocation nonce as an Index and zero as a Value. The Roots Tree gets updated whenever the Identity Claims Tree root gets updated. The executable code can be found here","title":"Identity Structure"},{"location":"getting-started/signature-claim/signature/","text":"Signature Claim Issuance To issue a claim by signing it, the only thing needed is access to your Baby Jubjub private key . 1. Retrieve hash of Claim's Index and hash of Claim's Value Starting from the Generic Claim previously created the first step we first need to extract the hash of its index and the hash of its value claimIndex, claimValue := claim.RawSlots() indexHash, _ := poseidon.Hash(core.ElemBytesToInts(claimIndex[:])) valueHash, _ := poseidon.Hash(core.ElemBytesToInts(claimValue[:])) 2. Hash the indexHash and the valueHash together and sign it // Poseidon Hash the indexHash and the valueHash together to get the claimHash claimHash, _ := merkletree.HashElems(indexHash, valueHash) // Sign the claimHash with the private key of the issuer claimSignature := babyJubjubPrivKey.SignPoseidon(claimHash.BigInt()) The executable code can be found here","title":"via Signature"},{"location":"getting-started/signature-claim/signature/#signature-claim-issuance","text":"To issue a claim by signing it, the only thing needed is access to your Baby Jubjub private key . 1. Retrieve hash of Claim's Index and hash of Claim's Value Starting from the Generic Claim previously created the first step we first need to extract the hash of its index and the hash of its value claimIndex, claimValue := claim.RawSlots() indexHash, _ := poseidon.Hash(core.ElemBytesToInts(claimIndex[:])) valueHash, _ := poseidon.Hash(core.ElemBytesToInts(claimValue[:])) 2. Hash the indexHash and the valueHash together and sign it // Poseidon Hash the indexHash and the valueHash together to get the claimHash claimHash, _ := merkletree.HashElems(indexHash, valueHash) // Sign the claimHash with the private key of the issuer claimSignature := babyJubjubPrivKey.SignPoseidon(claimHash.BigInt()) The executable code can be found here","title":"Signature Claim Issuance"},{"location":"getting-started/state-transition/new-identity-state/","text":"Add Claim to the Claims Tree At t=0, the situation is the same left from the Identity section of tutorial. Our identity is still at the Genesis State . The Claims Tree contains only the authClaim . The revocation and roots trees are empty. The state hasn't been published on-chain yet. Let's see what happens when if we decide to add a new claim to the Claims Tree. 1. Update the required dependencies. go get github.com/iden3/go-circuits 2. Add a new claim and fetch the new state package main import ( \"encoding/hex\" \"fmt\" \"math/big\" \"github.com/iden3/go-circuits\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/poseidon\" \"github.com/iden3/go-merkletree-sql\" ) // Change Identity State func main() { // GENESIS STATE: // 1. Generate Merkle Tree Proof for authClaim at Genesis State authMTPProof, _, _ := clt.GenerateProof(ctx, hIndex, clt.Root()) // 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State authNonRevMTPProof, _, _ := ret.GenerateProof(ctx, new(big.Int).SetUint64(revNonce), ret.Root()) // Snapshot of the Genesis State genesisTreeState := circuits.TreeState{ State: state, ClaimsRoot: clt.Root(), RevocationRoot: ret.Root(), RootOfRoots: rot.Root(), } // STATE 1: // Before updating the claims tree, add the claims tree root at Genesis state to the Roots tree. rot.Add(ctx, clt.Root().BigInt(), big.NewInt(0)) // Create a new random claim schemaHex := hex.EncodeToString([]byte(\"myAge_test_claim\")) schema, _ := core.NewSchemaHashFromHex(schemaHex) code := big.NewInt(51) newClaim, _ := core.NewClaim(schema, core.WithIndexDataInts(code, nil)) // Get hash Index and hash Value of the new claim hi, hv, _ := newClaim.HiHv() // Add claim to the Claims tree clt.Add(ctx, hi, hv) // Fetch the new Identity State newState, _ := merkletree.HashElems( clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) // Sign a message (hash of the genesis state + the new state) using your private key hashOldAndNewStates, _ := poseidon.Hash([]*big.Int{state.BigInt(), newState.BigInt()}) signature := babyJubjubPrivKey.SignPoseidon(hashOldAndNewStates) // Generate state transition inputs stateTransitionInputs := circuits.StateTransitionInputs{ ID: id, OldTreeState: genesisTreeState, NewState: newState, IsOldStateGenesis: true, AuthClaim: circuits.Claim{ Claim: authClaim, Proof: authMTPProof, NonRevProof: &circuits.ClaimNonRevStatus{ Proof: authNonRevMTPProof, }, }, Signature: signature, } // Perform marshalling of the state transition inputs inputBytes, _ := stateTransitionInputs.InputsMarshal() fmt.Println(string(inputBytes)) } After issuing a new claim, the claims tree gets modified and, therefore, the Identity State changes. To complete the state transition it is necessary to verify it inside a circuit. The type StateTransitionInputs lets us pack the inputs needed to generate a proof while the InputsMarshal() function turns it into a json file that can be used directly as State Transition Circuit inputs. These inputs will be used in the next section. The executable code can be found here","title":"Add Claim to the Claims Tree"},{"location":"getting-started/state-transition/new-identity-state/#add-claim-to-the-claims-tree","text":"At t=0, the situation is the same left from the Identity section of tutorial. Our identity is still at the Genesis State . The Claims Tree contains only the authClaim . The revocation and roots trees are empty. The state hasn't been published on-chain yet. Let's see what happens when if we decide to add a new claim to the Claims Tree. 1. Update the required dependencies. go get github.com/iden3/go-circuits 2. Add a new claim and fetch the new state package main import ( \"encoding/hex\" \"fmt\" \"math/big\" \"github.com/iden3/go-circuits\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/poseidon\" \"github.com/iden3/go-merkletree-sql\" ) // Change Identity State func main() { // GENESIS STATE: // 1. Generate Merkle Tree Proof for authClaim at Genesis State authMTPProof, _, _ := clt.GenerateProof(ctx, hIndex, clt.Root()) // 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State authNonRevMTPProof, _, _ := ret.GenerateProof(ctx, new(big.Int).SetUint64(revNonce), ret.Root()) // Snapshot of the Genesis State genesisTreeState := circuits.TreeState{ State: state, ClaimsRoot: clt.Root(), RevocationRoot: ret.Root(), RootOfRoots: rot.Root(), } // STATE 1: // Before updating the claims tree, add the claims tree root at Genesis state to the Roots tree. rot.Add(ctx, clt.Root().BigInt(), big.NewInt(0)) // Create a new random claim schemaHex := hex.EncodeToString([]byte(\"myAge_test_claim\")) schema, _ := core.NewSchemaHashFromHex(schemaHex) code := big.NewInt(51) newClaim, _ := core.NewClaim(schema, core.WithIndexDataInts(code, nil)) // Get hash Index and hash Value of the new claim hi, hv, _ := newClaim.HiHv() // Add claim to the Claims tree clt.Add(ctx, hi, hv) // Fetch the new Identity State newState, _ := merkletree.HashElems( clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt()) // Sign a message (hash of the genesis state + the new state) using your private key hashOldAndNewStates, _ := poseidon.Hash([]*big.Int{state.BigInt(), newState.BigInt()}) signature := babyJubjubPrivKey.SignPoseidon(hashOldAndNewStates) // Generate state transition inputs stateTransitionInputs := circuits.StateTransitionInputs{ ID: id, OldTreeState: genesisTreeState, NewState: newState, IsOldStateGenesis: true, AuthClaim: circuits.Claim{ Claim: authClaim, Proof: authMTPProof, NonRevProof: &circuits.ClaimNonRevStatus{ Proof: authNonRevMTPProof, }, }, Signature: signature, } // Perform marshalling of the state transition inputs inputBytes, _ := stateTransitionInputs.InputsMarshal() fmt.Println(string(inputBytes)) } After issuing a new claim, the claims tree gets modified and, therefore, the Identity State changes. To complete the state transition it is necessary to verify it inside a circuit. The type StateTransitionInputs lets us pack the inputs needed to generate a proof while the InputsMarshal() function turns it into a json file that can be used directly as State Transition Circuit inputs. These inputs will be used in the next section. The executable code can be found here","title":"Add Claim to the Claims Tree"},{"location":"getting-started/state-transition/on-chain-state-transition-remix/","text":"Remix Connect yout Metamask wallet to Polygon Mumbai Testnet. On the Remix Homepage , click \"Load from GitHub\" and import State.sol using the link: https://github.com/iden3/contracts/blob/master/contracts/State.sol Move to the \"Solidity Compiler\" section and compile State.sol . Move to the \"Deploy and Run Transaction\" section and modify the Environment to \"Injected web3\". If everything was set correctly, you should see Custom (80001) network below the environment drop-down menu.The system prompts you to connect to your MetaMask wallet. Make sure to select the \"Mumbai\" network on your Metamask before connecting the wallet. Make sure that the State contract is selected in the contract drop-down menu and \"Load contract from address\" adding 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 as contract address. Check identity state at T=0. To check the identity state call the getState function on the State.sol passing in your identifier. The identifier is the first public input in the public array returned from the solidity calldata from the previous tutorial. The result is zero as there's no identity state associated with that identifier because the identity state has never been published on-chain (yet!) Now update the identity state by calling the transitState function on State.sol. The outputs generated from the previous tutorial are passed as inputs to the transitState function. See the one-to-one mapping between the outputs from state transition and the inputs to the transitState function in the diagram below: transitState Function Inputs Check the new state. To check, call the getState function again by passing the value of the identifier you used above as an input to the transitState function. You can see that the console displays a new state: uint256:14531895531750268543323474544059484523319511522635242711319115705040584883009","title":"On chain state transition remix"},{"location":"getting-started/state-transition/on-chain-state-transition-remix/#remix","text":"Connect yout Metamask wallet to Polygon Mumbai Testnet. On the Remix Homepage , click \"Load from GitHub\" and import State.sol using the link: https://github.com/iden3/contracts/blob/master/contracts/State.sol Move to the \"Solidity Compiler\" section and compile State.sol . Move to the \"Deploy and Run Transaction\" section and modify the Environment to \"Injected web3\". If everything was set correctly, you should see Custom (80001) network below the environment drop-down menu.The system prompts you to connect to your MetaMask wallet. Make sure to select the \"Mumbai\" network on your Metamask before connecting the wallet. Make sure that the State contract is selected in the contract drop-down menu and \"Load contract from address\" adding 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 as contract address. Check identity state at T=0. To check the identity state call the getState function on the State.sol passing in your identifier. The identifier is the first public input in the public array returned from the solidity calldata from the previous tutorial. The result is zero as there's no identity state associated with that identifier because the identity state has never been published on-chain (yet!) Now update the identity state by calling the transitState function on State.sol. The outputs generated from the previous tutorial are passed as inputs to the transitState function. See the one-to-one mapping between the outputs from state transition and the inputs to the transitState function in the diagram below: transitState Function Inputs Check the new state. To check, call the getState function again by passing the value of the identifier you used above as an input to the transitState function. You can see that the console displays a new state: uint256:14531895531750268543323474544059484523319511522635242711319115705040584883009","title":"Remix"},{"location":"getting-started/state-transition/on-chain-state-transition/","text":"Verify the Proof On-Chain In order to complete the State Transition process it is necessary to verify the proof inside the State.sol contract. The transitState public function of the contract takes the proof generated in the previous section and verifies it on-chain. On verification, the identities mapping associated with the ID that is executing the transition gets updated. Hardhat 1. Add Mumbai Network inside your hardhat.config.js networks: { mumbai: { url: `${process.env.ALCHEMY_MUMBAI_URL}`, accounts: [`0x${process.env.MUMBAI_PRIVATE_KEY}`], } ... } 2. Add State.sol contract inside the contracts folder 3. Import the state contract from the existing Mumbai testnet address const contract = await hre.ethers.getContractAt(\"State\", \"0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3\"); 4. Add inputs from the proof generated in the previous section const id = \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" const oldState = \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" const newState = \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" const isOldStateGenesis = \"0x0000000000000000000000000000000000000000000000000000000000000001\" const a = [\"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\", \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\"] const b = [[\"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\", \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\"],[\"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\", \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\"]] const c = [\"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\", \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\"] Note: Do not use these same inputs for the next section of the tutorial. I already executed the State Transition using these inputs, so the transaction will fail. Instead, use the inputs that you locally generated. 5. Fetch identity state before state transition let identityState0 = await contract.getState(id); // 0 6. Execute state transition function await contract.transitState(id, oldState, newState, isOldStateGenesis, a, b, c); 7. Fetch identity state after state transition let identityState1 = await contract.getState(id); // 19736965623849496899943145128310994086117058864343685620577405145725675178459 Congratulations! You have successfully completed the identity state transition. Starting from the identifier, people will be able to track the status of an identity in a timestamped and tamper-proof way. The identifier remains fixed for the entire existence of an identity, while the identity state changes every time an identity gets updated, for example, when issuing or revoking a claim. As we'll see in the next section, every ZK proof generated from an identity will be checked against the identity state published on-chain. It is important to underline that: The mapping that associates an identifier with its current identity state is the only piece of information stored on-chain. Starting from the identifier and the identity state, it is impossible to retrieve any information stored in the identity trees, for example, reading the content of a claim (which is stored off-chain). There is no association between the ECDSA (Elliptical Curve Digital Signature Algorithm) key pair associated with the Ethereum address that executes the State Transition and the Baby Jubjub key pair which is used to control an identity. The executable code can be found here","title":"Verify the Proof On-Chain"},{"location":"getting-started/state-transition/on-chain-state-transition/#verify-the-proof-on-chain","text":"In order to complete the State Transition process it is necessary to verify the proof inside the State.sol contract. The transitState public function of the contract takes the proof generated in the previous section and verifies it on-chain. On verification, the identities mapping associated with the ID that is executing the transition gets updated.","title":"Verify the Proof On-Chain"},{"location":"getting-started/state-transition/on-chain-state-transition/#hardhat","text":"1. Add Mumbai Network inside your hardhat.config.js networks: { mumbai: { url: `${process.env.ALCHEMY_MUMBAI_URL}`, accounts: [`0x${process.env.MUMBAI_PRIVATE_KEY}`], } ... } 2. Add State.sol contract inside the contracts folder 3. Import the state contract from the existing Mumbai testnet address const contract = await hre.ethers.getContractAt(\"State\", \"0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3\"); 4. Add inputs from the proof generated in the previous section const id = \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" const oldState = \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" const newState = \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" const isOldStateGenesis = \"0x0000000000000000000000000000000000000000000000000000000000000001\" const a = [\"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\", \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\"] const b = [[\"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\", \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\"],[\"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\", \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\"]] const c = [\"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\", \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\"] Note: Do not use these same inputs for the next section of the tutorial. I already executed the State Transition using these inputs, so the transaction will fail. Instead, use the inputs that you locally generated. 5. Fetch identity state before state transition let identityState0 = await contract.getState(id); // 0 6. Execute state transition function await contract.transitState(id, oldState, newState, isOldStateGenesis, a, b, c); 7. Fetch identity state after state transition let identityState1 = await contract.getState(id); // 19736965623849496899943145128310994086117058864343685620577405145725675178459 Congratulations! You have successfully completed the identity state transition. Starting from the identifier, people will be able to track the status of an identity in a timestamped and tamper-proof way. The identifier remains fixed for the entire existence of an identity, while the identity state changes every time an identity gets updated, for example, when issuing or revoking a claim. As we'll see in the next section, every ZK proof generated from an identity will be checked against the identity state published on-chain. It is important to underline that: The mapping that associates an identifier with its current identity state is the only piece of information stored on-chain. Starting from the identifier and the identity state, it is impossible to retrieve any information stored in the identity trees, for example, reading the content of a claim (which is stored off-chain). There is no association between the ECDSA (Elliptical Curve Digital Signature Algorithm) key pair associated with the Ethereum address that executes the State Transition and the Baby Jubjub key pair which is used to control an identity. The executable code can be found here","title":"Hardhat"},{"location":"getting-started/state-transition/state-transition-proof/","text":"Generate Proof for State Transition The output of the previous tutorial was the result of a locally executed computation by the Identity Owner, namely moving from the genesis state to state 1. What if the person that executed the state transition wasn't actually the Identity Owner? What if the key used to sign the message was revoked? To ensure the state transition happens in a trustless way, it must be verified inside a circuit. The State Transition inputs generated earlier will be passed into the State Transition Circuit to generate a proof of the executed state transition. 1. Install Circom and SnarkJS. 2. Clone the repository that contains the compiled circuit git clone https://github.com/iden3/tutorial-examples.git This repository contains the stateTransition compiled circuit after a trusted setup. 3. Create a .json file with the state transition inputs from the previous tutorial For this, create a file named input.json inside the .stateTransition/stateTransition_js and then paste the inputs you generated in the previous tutorial. These inputs will be passed to the circuit and will be used to generate the zk proof. 4. Generate the proof From the compiled-circuits folder run: ./generate.sh stateTransition If everything worked fine, your terminal should display: [INFO] snarkJS: OK! 5. Display the proof You should now have 2 new files inside the /stateTransition/stateTransition_js directory, namely proof.json and public.json: proof.json contains the actual proof represented by the three arrays a, b, and c . It contains all the raw data of the proof that the SnarkJS library uses for verification of the proof. public.json is an array of the four elements representing the public inputs of the circuit. These are userID,oldUserState,newUserState,isOldStateGenesis 6. Export the proof in the Solidity calldata. The two files from the above step can also be exported as Solidity calldata in order to execute the verification on-chain. From the stateTransition_js directory run snarkjs generatecall . snarkjs generatecall Here is what the output would look like: [\"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\", \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\"], [[\"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\", \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\"],[\"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\", \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\"]], [\"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\", \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\"], [\"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\",\"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\",\"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\",\"0x0000000000000000000000000000000000000000000000000000000000000001\"] The Solidity calldata output represents: - `a[2]`, `b[2][2]`, `c[2]`, namely the proof - `public[4]`, namely the public inputs of the circuit In the next tutorial, we shall pass this proof to the State.sol smart contract in order to complete the State Transition function.","title":"Generate Proof for State Transition"},{"location":"getting-started/state-transition/state-transition-proof/#generate-proof-for-state-transition","text":"The output of the previous tutorial was the result of a locally executed computation by the Identity Owner, namely moving from the genesis state to state 1. What if the person that executed the state transition wasn't actually the Identity Owner? What if the key used to sign the message was revoked? To ensure the state transition happens in a trustless way, it must be verified inside a circuit. The State Transition inputs generated earlier will be passed into the State Transition Circuit to generate a proof of the executed state transition. 1. Install Circom and SnarkJS. 2. Clone the repository that contains the compiled circuit git clone https://github.com/iden3/tutorial-examples.git This repository contains the stateTransition compiled circuit after a trusted setup. 3. Create a .json file with the state transition inputs from the previous tutorial For this, create a file named input.json inside the .stateTransition/stateTransition_js and then paste the inputs you generated in the previous tutorial. These inputs will be passed to the circuit and will be used to generate the zk proof. 4. Generate the proof From the compiled-circuits folder run: ./generate.sh stateTransition If everything worked fine, your terminal should display: [INFO] snarkJS: OK! 5. Display the proof You should now have 2 new files inside the /stateTransition/stateTransition_js directory, namely proof.json and public.json: proof.json contains the actual proof represented by the three arrays a, b, and c . It contains all the raw data of the proof that the SnarkJS library uses for verification of the proof. public.json is an array of the four elements representing the public inputs of the circuit. These are userID,oldUserState,newUserState,isOldStateGenesis 6. Export the proof in the Solidity calldata. The two files from the above step can also be exported as Solidity calldata in order to execute the verification on-chain. From the stateTransition_js directory run snarkjs generatecall . snarkjs generatecall Here is what the output would look like: [\"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\", \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\"], [[\"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\", \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\"],[\"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\", \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\"]], [\"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\", \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\"], [\"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\",\"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\",\"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\",\"0x0000000000000000000000000000000000000000000000000000000000000001\"] The Solidity calldata output represents: - `a[2]`, `b[2][2]`, `c[2]`, namely the proof - `public[4]`, namely the public inputs of the circuit In the next tutorial, we shall pass this proof to the State.sol smart contract in order to complete the State Transition function.","title":"Generate Proof for State Transition"},{"location":"getting-started/state-transition/state-transition/","text":"Intro to State Transtion When an identity adds a new claim to her Claims Tree, the root of the tree and, consequently, the identity state change. The process of moving from one state to another is defined State Transition . The State Transtion is executed inside a circuit. The stateTransition circuit encodes a set of rules that must be respected to complete the state transition such as: The prover is the owner of the identity (checked using a digital signature by the private key corresponding the authClaim ) The authClaim of the prover hasn't been revoked. The identity state gets updated by calling the transitState smart contract function . To call this function, it is necessary to pass in the proof generated previously. On verification, the identities mapping gets updated associating the ID with a new IdS . This tutorial is split in 3 parts: Add Claim to the Claims Tree Generate Proof for State Transition Verify the Proof On-Chain Note: The Identity State Transition happens not only when an identity adds a new claim to the Claims Tree, but also when a claim gets updated or revoked (by adding it to the revocation tree).","title":"Intro to State Transition"},{"location":"getting-started/state-transition/state-transition/#intro-to-state-transtion","text":"When an identity adds a new claim to her Claims Tree, the root of the tree and, consequently, the identity state change. The process of moving from one state to another is defined State Transition . The State Transtion is executed inside a circuit. The stateTransition circuit encodes a set of rules that must be respected to complete the state transition such as: The prover is the owner of the identity (checked using a digital signature by the private key corresponding the authClaim ) The authClaim of the prover hasn't been revoked. The identity state gets updated by calling the transitState smart contract function . To call this function, it is necessary to pass in the proof generated previously. On verification, the identities mapping gets updated associating the ID with a new IdS . This tutorial is split in 3 parts: Add Claim to the Claims Tree Generate Proof for State Transition Verify the Proof On-Chain Note: The Identity State Transition happens not only when an identity adds a new claim to the Claims Tree, but also when a claim gets updated or revoked (by adding it to the revocation tree).","title":"Intro to State Transtion"},{"location":"guides/centralized-login/","text":"Centralized Login Use Case Overview This document will guide you through the steps required to integrate iden3's technology into your application's login. Introduction Iden3 is a complete decentralized identity management solution that allows users to leverage their pre-existing validated identities. This helps these users prove that they are who they claim to be; thus saving them the hassle of registering with each service (each requiring a validated identification) individually. One of the direct applications of the iden3 technology is to allow web services to reuse these identities for logging into their portals. The diagram below shows the steps of the backend process; follow these to enable a user gain access to your application using the iden3 identity system once the s/he has requested to log in. Iden3 provides an SDK to take care of requesting and verifying the identity so that the users can be authenticated. Platforms Supported JavaScript: https://github.com/iden3/iden3js Go: https://github.com/iden3/go-iden3 Pre-requirements The minimum requirements for a functional centralized login include: The iden3 wallet service has been deployed. A user attempting to log in has at least one valid identity. Integration A JavaScript reference implementation of how a third-party can integrate the iden3 solution to log in to its application can be found at: https://github.com/iden3/centralized-login-demo . In this example, the external service includes a front-end and a back-end server. Let's see how this division into the front-end and the back-end actually works: Front-End On the front-end, you need to embed a button to initiate the login process. You will also need to display a QR code that the user can scan to complete the authentication. After the button is pressed, the front-end makes a request to the back-end to start the identity authentication process and waits for the response containing the QR code to be displayed and scanned by the user. In the reference implementation, this is achieved by the JavaScript function getLoginData() , found in frontend/index.js. This code shows how to: Send a request for a new requestIdenAssert packet to the centralized application back-end. Open a WebSocket between the front-end and back-end. Display a QR code containing the requestIdenAssert packet to be signed by iden3's wallet. Back-End Generating Requests of Identity Assertion On the back-end, you will need to prepare a new API endpoint to handle the requestIdenAssert() petitions from the front-end. In the reference implementation, we use GET/login by calling the JavaScript function: const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, timeout); or the Go function: requestIdenAssert := NewRequestIdenAssert(nonceDb, origin, timeout) where: nonceDB is a NonceDB object generated by calling an API function and stored in a RAM database. origin is the domain of the emitter of the request, for example, myweb.com . timeout is the timeout in seconds, for example, two minutes ( 120s ). The nonceDB is obtained by calling the following JavaScript function: const nonceDB = new iden3.protocols.NonceDB(); or the Go function: ``` {.sourceCode .c nonceDb := core.NewNonceDb()} Once you have the *signatureRequest* object, you can return it back to the front-end so that it can be displayed. #### Verifying signedPacket On the back-end, you will also need to prepare a new API endpoint to handle the responses from the iden3 wallet containing the *signedPacket*. In the reference implementation, we use *POST /login* to allow the walled to send the signed data. To perform the verification in the newly added endpoint you just need to call the *iden3js* library: ``` {.sourceCode .javascript} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); or the go-iden3 library: verified, err := signedPacketVerifier. VerifySignedPacketIdenAssert(signedPacket, nonceDB, origin) where: nonceDB is the NonceDB object generated earlier. origin is the domain of the emitter of the request, for example, myweb.com . signedPacket is the signed packet sent by the iden3 wallet. verified is null if verification fails. SDK Installation iden3js Installation npm install --save @iden3/iden3 Import const iden3 = require('iden3'); go-iden3 Installation go get github.com/iden3/go-iden3 Import import { \"github.com/iden3/go-iden3/services/signedpacketsrv\" }","title":"Centralized Login Use Case"},{"location":"guides/centralized-login/#centralized-login-use-case","text":"","title":"Centralized Login Use Case"},{"location":"guides/centralized-login/#overview","text":"This document will guide you through the steps required to integrate iden3's technology into your application's login.","title":"Overview"},{"location":"guides/centralized-login/#introduction","text":"Iden3 is a complete decentralized identity management solution that allows users to leverage their pre-existing validated identities. This helps these users prove that they are who they claim to be; thus saving them the hassle of registering with each service (each requiring a validated identification) individually. One of the direct applications of the iden3 technology is to allow web services to reuse these identities for logging into their portals. The diagram below shows the steps of the backend process; follow these to enable a user gain access to your application using the iden3 identity system once the s/he has requested to log in. Iden3 provides an SDK to take care of requesting and verifying the identity so that the users can be authenticated.","title":"Introduction"},{"location":"guides/centralized-login/#platforms-supported","text":"JavaScript: https://github.com/iden3/iden3js Go: https://github.com/iden3/go-iden3","title":"Platforms Supported"},{"location":"guides/centralized-login/#pre-requirements","text":"The minimum requirements for a functional centralized login include: The iden3 wallet service has been deployed. A user attempting to log in has at least one valid identity.","title":"Pre-requirements"},{"location":"guides/centralized-login/#integration","text":"A JavaScript reference implementation of how a third-party can integrate the iden3 solution to log in to its application can be found at: https://github.com/iden3/centralized-login-demo . In this example, the external service includes a front-end and a back-end server. Let's see how this division into the front-end and the back-end actually works:","title":"Integration"},{"location":"guides/centralized-login/#front-end","text":"On the front-end, you need to embed a button to initiate the login process. You will also need to display a QR code that the user can scan to complete the authentication. After the button is pressed, the front-end makes a request to the back-end to start the identity authentication process and waits for the response containing the QR code to be displayed and scanned by the user. In the reference implementation, this is achieved by the JavaScript function getLoginData() , found in frontend/index.js. This code shows how to: Send a request for a new requestIdenAssert packet to the centralized application back-end. Open a WebSocket between the front-end and back-end. Display a QR code containing the requestIdenAssert packet to be signed by iden3's wallet.","title":"Front-End"},{"location":"guides/centralized-login/#back-end","text":"","title":"Back-End"},{"location":"guides/centralized-login/#generating-requests-of-identity-assertion","text":"On the back-end, you will need to prepare a new API endpoint to handle the requestIdenAssert() petitions from the front-end. In the reference implementation, we use GET/login by calling the JavaScript function: const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, timeout); or the Go function: requestIdenAssert := NewRequestIdenAssert(nonceDb, origin, timeout) where: nonceDB is a NonceDB object generated by calling an API function and stored in a RAM database. origin is the domain of the emitter of the request, for example, myweb.com . timeout is the timeout in seconds, for example, two minutes ( 120s ). The nonceDB is obtained by calling the following JavaScript function: const nonceDB = new iden3.protocols.NonceDB(); or the Go function: ``` {.sourceCode .c nonceDb := core.NewNonceDb()} Once you have the *signatureRequest* object, you can return it back to the front-end so that it can be displayed. #### Verifying signedPacket On the back-end, you will also need to prepare a new API endpoint to handle the responses from the iden3 wallet containing the *signedPacket*. In the reference implementation, we use *POST /login* to allow the walled to send the signed data. To perform the verification in the newly added endpoint you just need to call the *iden3js* library: ``` {.sourceCode .javascript} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); or the go-iden3 library: verified, err := signedPacketVerifier. VerifySignedPacketIdenAssert(signedPacket, nonceDB, origin) where: nonceDB is the NonceDB object generated earlier. origin is the domain of the emitter of the request, for example, myweb.com . signedPacket is the signed packet sent by the iden3 wallet. verified is null if verification fails.","title":"Generating Requests of Identity Assertion"},{"location":"guides/centralized-login/#sdk-installation","text":"","title":"SDK Installation"},{"location":"guides/centralized-login/#iden3js","text":"","title":"iden3js"},{"location":"guides/centralized-login/#installation","text":"npm install --save @iden3/iden3","title":"Installation"},{"location":"guides/centralized-login/#import","text":"const iden3 = require('iden3');","title":"Import"},{"location":"guides/centralized-login/#go-iden3","text":"","title":"go-iden3"},{"location":"guides/centralized-login/#installation_1","text":"go get github.com/iden3/go-iden3","title":"Installation"},{"location":"guides/centralized-login/#import_1","text":"import { \"github.com/iden3/go-iden3/services/signedpacketsrv\" }","title":"Import"},{"location":"guides/circom-and-snarkjs/","text":"How to Use Circom and SnarkJS? Hello and welcome!! In this guide, we'll explain how to create your first zero-knowledge Snark circuit using Circom and SnarkJS . Circom is a library that allows you to build circuits to be used in zero-knowledge proofs. While SnarkJS is an independent implementation of the zk-SNARK protocol (fully written in JavaScript), Circom is designed to work with SnarkJS. In other words, any circuit you build in Circom can be used in SnarkJS. We'll start by covering various techniques to write circuits; then we shall move on to creating and verifying a proof off-chain, and finally, finish it off by repeating this process on-chain (on Ethereum). If you have zero knowledge about zero-knowledge \ud83d\ude0b or are unsure about what a zk-SNARK is, we recommend you read this page first. To get started, click here .","title":"How to Use Circom and SnarkJS?"},{"location":"guides/circom-and-snarkjs/#how-to-use-circom-and-snarkjs","text":"Hello and welcome!! In this guide, we'll explain how to create your first zero-knowledge Snark circuit using Circom and SnarkJS . Circom is a library that allows you to build circuits to be used in zero-knowledge proofs. While SnarkJS is an independent implementation of the zk-SNARK protocol (fully written in JavaScript), Circom is designed to work with SnarkJS. In other words, any circuit you build in Circom can be used in SnarkJS. We'll start by covering various techniques to write circuits; then we shall move on to creating and verifying a proof off-chain, and finally, finish it off by repeating this process on-chain (on Ethereum). If you have zero knowledge about zero-knowledge \ud83d\ude0b or are unsure about what a zk-SNARK is, we recommend you read this page first. To get started, click here .","title":"How to Use Circom and SnarkJS?"},{"location":"protocol/bjjkey/","text":"AuthBJJCredential AuthBJJCredential is a primary credential for each identity. It represents an authorization operational key. Hex of the current auth claim schema is ca938857241db9451ea329256b9c06e5 . This claim must be presented in most circuits for identity verification. A Baby Jubjub key uses a specific elliptic curve defined over the large prime subgroup of the BN128 elliptic curve. To know more about the bjj key, you can visit this page . X and Y values of the bjj public key are part of the Index data slots [I_2] and [I_3]. You can find below an example of a claim entry: Index: i_0: [ 128 bits] 269270088098491255471307608775043319525 // auth schema (big integer from ca938857241db9451ea329256b9c06e5) [ 32 bits ] 00010000000000000000 // header flags: first 000 - self claim 1 - expiration is set. [ 32 bits ] 0 [ 61 bits ] 0 i_1: [ 253 bits] 0 i_2: [ 253 bits] 15730379921066174438220083697399546667862601297001890929936158339406931652649 // x part of BJJ pubkey i_3: [ 253 bits] 5635420193976628435572861747946801377895543276711153351053385881432935772762 // y part of BJJ pubkey Value: v_0: [ 64 bits ] 2484496687 // revocation nonce [ 64 bits ] 1679670808 // expiration timestamp [ 125 bits] 0 v_1: [ 253 bits] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"AuthBJJCredential"},{"location":"protocol/bjjkey/#authbjjcredential","text":"AuthBJJCredential is a primary credential for each identity. It represents an authorization operational key. Hex of the current auth claim schema is ca938857241db9451ea329256b9c06e5 . This claim must be presented in most circuits for identity verification. A Baby Jubjub key uses a specific elliptic curve defined over the large prime subgroup of the BN128 elliptic curve. To know more about the bjj key, you can visit this page . X and Y values of the bjj public key are part of the Index data slots [I_2] and [I_3]. You can find below an example of a claim entry: Index: i_0: [ 128 bits] 269270088098491255471307608775043319525 // auth schema (big integer from ca938857241db9451ea329256b9c06e5) [ 32 bits ] 00010000000000000000 // header flags: first 000 - self claim 1 - expiration is set. [ 32 bits ] 0 [ 61 bits ] 0 i_1: [ 253 bits] 0 i_2: [ 253 bits] 15730379921066174438220083697399546667862601297001890929936158339406931652649 // x part of BJJ pubkey i_3: [ 253 bits] 5635420193976628435572861747946801377895543276711153351053385881432935772762 // y part of BJJ pubkey Value: v_0: [ 64 bits ] 2484496687 // revocation nonce [ 64 bits ] 1679670808 // expiration timestamp [ 125 bits] 0 v_1: [ 253 bits] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"AuthBJJCredential"},{"location":"protocol/circuits/","text":"Circuits Template Docs Example Let's understand how circuits and templates can be described by their graphs. Just compare the following .circom code with its visual graph displayed underneath. The code: template Example () { signal input input1; signal input input2; signal input input3; signal input input4; signal input input5; component template1 = Template1(); template1.in1 = input1; template1.in2 = input2; template1.in3 = input3; component template2 = Template2(); template2.in1 = input3; template2.in2 = input4; } The graph: graph TB Input1 --> Template1 Input2 --> Template1 Input3 --> Template1 Input3 --> Template2 Input4 --> Template2 classDef inputStyle fill:#ecb3ff class Input1,Input2,Input3,Input4,Input5,Input6,Input7,Input8,Input9 inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class Template1,Template2,Template3 circuitStyle; Basic Templates Basic templates are not used independently to create circuits but are used as the building blocks for other templates. checkClaimExists This circuit checks if a claim exists in the sparse Merkle tree. By \"exists\", we mean that a value Hv (hash of all values slots) is located by path Hi (hash of all index slots) in the tree. graph TB claim --> getClaimHiHv getClaimHiHv -- key --> SMTVerifier[SMTVerifier] getClaimHiHv -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[0] -- fnc --> SMTVerifier zero2[0] -- oldKey --> SMTVerifier zero3[0] -- oldValue --> SMTVerifier zero4[0] -- isOld0 --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getClaimHiHv,SMTVerifier circuitStyle; checkClaimNonRev The circuit checks that the claim does not exist in the sparse Merkle tree. That means that the tree leaf is empty by a path, which is defined by the claim nonce. graph TB claim --> getNonce getNonce -- key --> SMTVerifier[SMTVerifier] 0 -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[1] -- fnc --> SMTVerifier noAux -- isOld0 --> SMTVerifier auxHi -- oldKey --> SMTVerifier auxHv -- oldValue --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot,noAux,auxHi,auxHv inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getNonce,SMTVerifier circuitStyle; checkChallengeSignature This circuit checks if the challenge signature is correct. The public key for verification is extracted from the claim. graph TB claim --> getPubKeyFromClaim getPubKeyFromClaim -- Ax --> EdDSAPoseidonVerifier getPubKeyFromClaim -- Ay --> EdDSAPoseidonVerifier signatureS -- S --> EdDSAPoseidonVerifier signatureR8X -- R8X --> EdDSAPoseidonVerifier signatureR8Y -- R8Y --> EdDSAPoseidonVerifier challenge -- M --> EdDSAPoseidonVerifier classDef inputStyle fill:#ecb3ff class claim,getPubKey,signatureS,signatureR8Y,signatureR8X,challenge inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class getPubKeyFromClaim,EdDSAPoseidonVerifier circuitStyle verifyIdenStateMatchesRoot The circuit calculates the identity state from the three Merkle tree roots and checks if it is equal to the expected state. graph TB claimsTreeRoot --> calcRoot revTreeRoot --> calcRoot rootsTreeRoot --> calcRoot calcRoot --> equal[=] expectedState ---> equal classDef inputStyle fill:#ecb3ff class claimsTreeRoot,revTreeRoot,rootsTreeRoot,expectedState inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class calcRoot,equal circuitStyle Query This circuit checks that an expression within an operator and its value are true. For example in=\"1\", operator=\"4\", value=[\"5\",\"2\",\"3\"] is true because \"4\" is \"not in\" operator and \"1\" is not in the [\"5\",\"2\",\"3\"] array. See all the operators in the circuit comments. The circuit graph is not represented here due to complexity. Functional Templates These are the templates that the Iden3 system mostly uses to generate and verify proofs directly. A functional template may use other functional templates as its building blocks. idOwnershipBySignature This circuit checks the ownership of a specific identity in the following way: The claim with the public key should exist in the claims tree. The claim with the public key should not be revoked. The signature of a challenge should be valid. The state should be equal to \"expected\" from the blockchain. The above criteria enable a verifier to check that the challenge is signed by an identity, which state is timestamped on the blockchain and if it includes the non-revoked claim with the relevant public key. CredentialAtomicQueryMTP This circuit checks that an issuer has issued a claim for identity and validates the ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template Verifies the claim subject, the schema and the expiration time. Checks if the issuer claim exists in the issuer claims tree. Checks if the issuer claim is not revoked by an issuer. Checks if the issuer claim satisfies a query. CredentialAtomicQuerySig This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template. Verifies the claim subject, the schema and the expiration time Checks if the issuer claim exists in the issuer claims tree. Verifies the claim signature by the issuer. Verifies if the issuer state matches with the one from the blockchain as the public input. Checks if the issuer claim satisfies a query.","title":"Circuits"},{"location":"protocol/circuits/#circuits","text":"","title":"Circuits"},{"location":"protocol/circuits/#template-docs-example","text":"Let's understand how circuits and templates can be described by their graphs. Just compare the following .circom code with its visual graph displayed underneath. The code: template Example () { signal input input1; signal input input2; signal input input3; signal input input4; signal input input5; component template1 = Template1(); template1.in1 = input1; template1.in2 = input2; template1.in3 = input3; component template2 = Template2(); template2.in1 = input3; template2.in2 = input4; } The graph: graph TB Input1 --> Template1 Input2 --> Template1 Input3 --> Template1 Input3 --> Template2 Input4 --> Template2 classDef inputStyle fill:#ecb3ff class Input1,Input2,Input3,Input4,Input5,Input6,Input7,Input8,Input9 inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class Template1,Template2,Template3 circuitStyle;","title":"Template Docs Example"},{"location":"protocol/circuits/#basic-templates","text":"Basic templates are not used independently to create circuits but are used as the building blocks for other templates.","title":"Basic Templates"},{"location":"protocol/circuits/#checkclaimexists","text":"This circuit checks if a claim exists in the sparse Merkle tree. By \"exists\", we mean that a value Hv (hash of all values slots) is located by path Hi (hash of all index slots) in the tree. graph TB claim --> getClaimHiHv getClaimHiHv -- key --> SMTVerifier[SMTVerifier] getClaimHiHv -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[0] -- fnc --> SMTVerifier zero2[0] -- oldKey --> SMTVerifier zero3[0] -- oldValue --> SMTVerifier zero4[0] -- isOld0 --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getClaimHiHv,SMTVerifier circuitStyle;","title":"checkClaimExists"},{"location":"protocol/circuits/#checkclaimnonrev","text":"The circuit checks that the claim does not exist in the sparse Merkle tree. That means that the tree leaf is empty by a path, which is defined by the claim nonce. graph TB claim --> getNonce getNonce -- key --> SMTVerifier[SMTVerifier] 0 -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[1] -- fnc --> SMTVerifier noAux -- isOld0 --> SMTVerifier auxHi -- oldKey --> SMTVerifier auxHv -- oldValue --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot,noAux,auxHi,auxHv inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getNonce,SMTVerifier circuitStyle;","title":"checkClaimNonRev"},{"location":"protocol/circuits/#checkchallengesignature","text":"This circuit checks if the challenge signature is correct. The public key for verification is extracted from the claim. graph TB claim --> getPubKeyFromClaim getPubKeyFromClaim -- Ax --> EdDSAPoseidonVerifier getPubKeyFromClaim -- Ay --> EdDSAPoseidonVerifier signatureS -- S --> EdDSAPoseidonVerifier signatureR8X -- R8X --> EdDSAPoseidonVerifier signatureR8Y -- R8Y --> EdDSAPoseidonVerifier challenge -- M --> EdDSAPoseidonVerifier classDef inputStyle fill:#ecb3ff class claim,getPubKey,signatureS,signatureR8Y,signatureR8X,challenge inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class getPubKeyFromClaim,EdDSAPoseidonVerifier circuitStyle","title":"checkChallengeSignature"},{"location":"protocol/circuits/#verifyidenstatematchesroot","text":"The circuit calculates the identity state from the three Merkle tree roots and checks if it is equal to the expected state. graph TB claimsTreeRoot --> calcRoot revTreeRoot --> calcRoot rootsTreeRoot --> calcRoot calcRoot --> equal[=] expectedState ---> equal classDef inputStyle fill:#ecb3ff class claimsTreeRoot,revTreeRoot,rootsTreeRoot,expectedState inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class calcRoot,equal circuitStyle","title":"verifyIdenStateMatchesRoot"},{"location":"protocol/circuits/#query","text":"This circuit checks that an expression within an operator and its value are true. For example in=\"1\", operator=\"4\", value=[\"5\",\"2\",\"3\"] is true because \"4\" is \"not in\" operator and \"1\" is not in the [\"5\",\"2\",\"3\"] array. See all the operators in the circuit comments. The circuit graph is not represented here due to complexity.","title":"Query"},{"location":"protocol/circuits/#functional-templates","text":"These are the templates that the Iden3 system mostly uses to generate and verify proofs directly. A functional template may use other functional templates as its building blocks.","title":"Functional Templates"},{"location":"protocol/circuits/#idownershipbysignature","text":"This circuit checks the ownership of a specific identity in the following way: The claim with the public key should exist in the claims tree. The claim with the public key should not be revoked. The signature of a challenge should be valid. The state should be equal to \"expected\" from the blockchain. The above criteria enable a verifier to check that the challenge is signed by an identity, which state is timestamped on the blockchain and if it includes the non-revoked claim with the relevant public key.","title":"idOwnershipBySignature"},{"location":"protocol/circuits/#credentialatomicquerymtp","text":"This circuit checks that an issuer has issued a claim for identity and validates the ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template Verifies the claim subject, the schema and the expiration time. Checks if the issuer claim exists in the issuer claims tree. Checks if the issuer claim is not revoked by an issuer. Checks if the issuer claim satisfies a query.","title":"CredentialAtomicQueryMTP"},{"location":"protocol/circuits/#credentialatomicquerysig","text":"This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template. Verifies the claim subject, the schema and the expiration time Checks if the issuer claim exists in the issuer claims tree. Verifies the claim signature by the issuer. Verifies if the issuer state matches with the one from the blockchain as the public input. Checks if the issuer claim satisfies a query.","title":"CredentialAtomicQuerySig"},{"location":"protocol/claim-schema/","text":"Claim Schema In order to reuse claims across different services is necessary to keep consistent data formatting. A Claim Schema encodes the structure of a particular claim by defining the usage of data slots. Iden3 claims store data inside four data slots: two index slots(i_2,i_3) and two value slots (v_2, v_3). To properly design and fill a claim with information, it is necessary to define which data should be stored inside which data slots. These rules are encoded inside the Claim Schema. Schemas are described via JSON-LD documents. Here an example of Claim Schema of type KYCCountryOfResidenceCredential . The countryCode should be stored in IndexDataSlotA while the documentType in ValueDataSlotB: ... \"countryCode\": { \"@id\": \"kyc-vocab:countryCode\", \"@type\": \"serialization:IndexDataSlotA\" }, \"documentType\": { \"@id\": \"kyc-vocab:documentType\", \"@type\": \"serialization:ValueDataSlotB\" } ... A claim issuer could reuse exisitng claim schemas or create new ones from scratch. Example: Auth Claim Schema Github Document { \"@context\": [{ \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"AuthBJJCredential\": { \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/auth.json-ld#AuthBJJCredential\", \"@context\": { \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"auth-vocab\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/auth.md#\", \"serialization\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\", \"x\": { \"@id\": \"auth-vocab:x\", \"@type\": \"serialization:IndexDataSlotA\" }, \"y\": { \"@id\": \"auth-vocab:y\", \"@type\": \"serialization:IndexDataSlotB\" } } } }] } This document describes the schema for a claim of type AuthBJJCredential . The @id contains the unique url that contains the JSON-LD Document. The auth-vocab contains the url that describes the value types stored inside this claim, in this case x and y . The serialization contains the instructions need to parse the raw claim into a JSON-LD document (and viceversa). The last part of the document contains a reference to the value types x and y . Their @id is corresponding description in the auth-vocab while the @type indicates where the values should be stored inside the claim. In this case x and y should, respectively, be stored in IndexDataSlotA and IndexDataSlotB . Schema Hash The first index slot (i_0) of a Claim should store the claim schema itself. Storing the whole JSON-LD document inside the claim would be highly inefficient, so only an hash is stored inside the claim. The Schema Hash stored inside a claim is the last 16 bytes of the result of hashing together: schemaBytes , the Claim Schema JSON-LD document in bytes format credentialType , the credential type in bytes format. var sHash core.SchemaHash hash := Keccak256(schemaBytes, []byte(credentialType)) copy(sHash[:], hash[len(hash)-16:]) For example, in the case of the Auth Claim the schema hash would be var sHash core.SchemaHash h := Keccak256(schemaBytes, []byte(\"AuthBJJCredential\")) copy(sHash[:], h[len(h)-16:]) // sHash = ca938857241db9451ea329256b9c06e5","title":"Claim Schema"},{"location":"protocol/claim-schema/#claim-schema","text":"In order to reuse claims across different services is necessary to keep consistent data formatting. A Claim Schema encodes the structure of a particular claim by defining the usage of data slots. Iden3 claims store data inside four data slots: two index slots(i_2,i_3) and two value slots (v_2, v_3). To properly design and fill a claim with information, it is necessary to define which data should be stored inside which data slots. These rules are encoded inside the Claim Schema. Schemas are described via JSON-LD documents. Here an example of Claim Schema of type KYCCountryOfResidenceCredential . The countryCode should be stored in IndexDataSlotA while the documentType in ValueDataSlotB: ... \"countryCode\": { \"@id\": \"kyc-vocab:countryCode\", \"@type\": \"serialization:IndexDataSlotA\" }, \"documentType\": { \"@id\": \"kyc-vocab:documentType\", \"@type\": \"serialization:ValueDataSlotB\" } ... A claim issuer could reuse exisitng claim schemas or create new ones from scratch.","title":"Claim Schema"},{"location":"protocol/claim-schema/#example-auth-claim-schema","text":"Github Document { \"@context\": [{ \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"AuthBJJCredential\": { \"@id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/auth.json-ld#AuthBJJCredential\", \"@context\": { \"@version\": 1.1, \"@protected\": true, \"id\": \"@id\", \"type\": \"@type\", \"auth-vocab\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/auth.md#\", \"serialization\": \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\", \"x\": { \"@id\": \"auth-vocab:x\", \"@type\": \"serialization:IndexDataSlotA\" }, \"y\": { \"@id\": \"auth-vocab:y\", \"@type\": \"serialization:IndexDataSlotB\" } } } }] } This document describes the schema for a claim of type AuthBJJCredential . The @id contains the unique url that contains the JSON-LD Document. The auth-vocab contains the url that describes the value types stored inside this claim, in this case x and y . The serialization contains the instructions need to parse the raw claim into a JSON-LD document (and viceversa). The last part of the document contains a reference to the value types x and y . Their @id is corresponding description in the auth-vocab while the @type indicates where the values should be stored inside the claim. In this case x and y should, respectively, be stored in IndexDataSlotA and IndexDataSlotB .","title":"Example: Auth Claim Schema"},{"location":"protocol/claim-schema/#schema-hash","text":"The first index slot (i_0) of a Claim should store the claim schema itself. Storing the whole JSON-LD document inside the claim would be highly inefficient, so only an hash is stored inside the claim. The Schema Hash stored inside a claim is the last 16 bytes of the result of hashing together: schemaBytes , the Claim Schema JSON-LD document in bytes format credentialType , the credential type in bytes format. var sHash core.SchemaHash hash := Keccak256(schemaBytes, []byte(credentialType)) copy(sHash[:], hash[len(hash)-16:]) For example, in the case of the Auth Claim the schema hash would be var sHash core.SchemaHash h := Keccak256(schemaBytes, []byte(\"AuthBJJCredential\")) copy(sHash[:], h[len(h)-16:]) // sHash = ca938857241db9451ea329256b9c06e5","title":"Schema Hash"},{"location":"protocol/claims-structure/","text":"Claim Data Structure graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Common Structure A claim always contains a subject, that can be: - Self : The claim says something about itself. The subject is implicit, and it's the identity that makes claim. - OtherIden : The claim says something about some other identity (identifies by other's ID). - Object : The claim says something about an object (identifies by the object's ID). If the subject is Self - identity , sections i_1, v_1 can be empty. if the subject is NOT Self , the id(OtherIden) of the Identity/Object can be in the Index(i_1) or the Value(v_1) part of the claim. This is encoded in a header bit. h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0 Claim Schema Schemas define the type of data inside a claim link . Index slots i_2 , i_3 and value slots v_2 , v_3 are the data slots for user data. Index vs Value When to Use Index Slots and Value Slots? Claims are stored in the Merkle tree and the hash of the index slots ( hash(i_0,i_1,i_2,i_3) ) is unique for the whole tree. It means that you cannot have two claims with the same index inside the tree. As opposite to the index, the values slots could be the same for different claims if their indexes are different.","title":"Structure"},{"location":"protocol/claims-structure/#claim-data-structure","text":"graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv","title":"Claim Data Structure"},{"location":"protocol/claims-structure/#common-structure","text":"A claim always contains a subject, that can be: - Self : The claim says something about itself. The subject is implicit, and it's the identity that makes claim. - OtherIden : The claim says something about some other identity (identifies by other's ID). - Object : The claim says something about an object (identifies by the object's ID). If the subject is Self - identity , sections i_1, v_1 can be empty. if the subject is NOT Self , the id(OtherIden) of the Identity/Object can be in the Index(i_1) or the Value(v_1) part of the claim. This is encoded in a header bit. h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"Common Structure"},{"location":"protocol/claims-structure/#claim-schema","text":"Schemas define the type of data inside a claim link . Index slots i_2 , i_3 and value slots v_2 , v_3 are the data slots for user data.","title":"Claim Schema"},{"location":"protocol/claims-structure/#index-vs-value","text":"When to Use Index Slots and Value Slots? Claims are stored in the Merkle tree and the hash of the index slots ( hash(i_0,i_1,i_2,i_3) ) is unique for the whole tree. It means that you cannot have two claims with the same index inside the tree. As opposite to the index, the values slots could be the same for different claims if their indexes are different.","title":"Index vs Value"},{"location":"protocol/main-circuits/","text":"Main Circuits This iden3 circuits are the heart of the protocol. The main ones are: stateTransition.circom , checks the execution of the identity state transtion by taking the old identity state and the new identity state as inputs. authentication.circom , checks that the prover is owner of an identity. credentialAtomicQueryMTP.circom , checks that a claim issued to the prover (and added to issuer's Claims Tree) satisfies a query set by the verifier. credentialAtomicQuerySig.circom checks that a claim issued to the prover (and signed by the Issuer) satisfies a query set by the verifier. You can find all the source code on Github - Iden3 Circuits . All the proving and verification keys necessary to use the circuits were generated after a Trusted Setup Ceremony. Details here: Iden3 Protocol Phase2 Trusted Setup Ceremony stateTransition Github Example of instantiation Instantiation Parameters nLevels Merkle tree depth level for Claims tree Inputs Input Description Public or Private userID Prover's Identifier Public oldUserState Prover's Identity State (before transition) Public newUserState Prover's Identity State (after transition) Public isOldStateGenesis \"1\" indicates that the old state is genesis: it means that this is the first State Transition, otherwise \"0\" Public claimsTreeRoot Prover's Claims Tree Root Private authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree Private authClaim[8] Prover's Auth Claim Private revTreeRoot Prover's Revocation Tree Root Private authClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private rootsTreeRoot Prover's Roots Tree Root Private signatureR8x Signature of the challenge (Rx point) Private signatureR8y Signature of the challenge (Ry point) Private signatureS Signature of the challenge (S point) Private Scope If oldState is genesis, verifies that userID is derived from the oldUserState (= genesis state). Performed using cutId() , cutState() and isEqual() templates newUserState is different than zero using isZero() comparator oldUserState and newUserState are different using isEqual() Verifies user's identity ownership using idOwnershipBySignature(nLevels) template. The message signed by the user is H(oldstate, newstate) where H is a Poseidon hash function executed inside the Poseidon(nInputs) template Circuit Specific Files (From Trusted Setup) Final zkey circuit_final.zkey Verification Key verification_key.json WASM Witness Generator circuit.wasm authentication Github Example of instantiation coming soon! credentialAtomicQueryMTP Github Example of instantiation This circuit checks that an issuer has issued a claim for identity and validates the ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template Verifies the claim subject, the schema and the expiration time. Checks if the issuer claim exists in the issuer claims tree. Checks if the issuer claim is not revoked by an issuer. Checks if the issuer claim satisfies a query. credentialAtomicQuerySig Github Example of instantiation This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template. Verifies the claim subject, the schema and the expiration time Checks if the issuer claim exists in the issuer claims tree. Verifies the claim signature by the issuer. Verifies if the issuer state matches with the one from the blockchain as the public input. Checks if the issuer claim satisfies a query.","title":"Main Circuits"},{"location":"protocol/main-circuits/#main-circuits","text":"This iden3 circuits are the heart of the protocol. The main ones are: stateTransition.circom , checks the execution of the identity state transtion by taking the old identity state and the new identity state as inputs. authentication.circom , checks that the prover is owner of an identity. credentialAtomicQueryMTP.circom , checks that a claim issued to the prover (and added to issuer's Claims Tree) satisfies a query set by the verifier. credentialAtomicQuerySig.circom checks that a claim issued to the prover (and signed by the Issuer) satisfies a query set by the verifier. You can find all the source code on Github - Iden3 Circuits . All the proving and verification keys necessary to use the circuits were generated after a Trusted Setup Ceremony. Details here: Iden3 Protocol Phase2 Trusted Setup Ceremony","title":"Main Circuits"},{"location":"protocol/main-circuits/#statetransition","text":"Github Example of instantiation","title":"stateTransition"},{"location":"protocol/main-circuits/#instantiation-parameters","text":"nLevels Merkle tree depth level for Claims tree","title":"Instantiation Parameters"},{"location":"protocol/main-circuits/#inputs","text":"Input Description Public or Private userID Prover's Identifier Public oldUserState Prover's Identity State (before transition) Public newUserState Prover's Identity State (after transition) Public isOldStateGenesis \"1\" indicates that the old state is genesis: it means that this is the first State Transition, otherwise \"0\" Public claimsTreeRoot Prover's Claims Tree Root Private authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree Private authClaim[8] Prover's Auth Claim Private revTreeRoot Prover's Revocation Tree Root Private authClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private rootsTreeRoot Prover's Roots Tree Root Private signatureR8x Signature of the challenge (Rx point) Private signatureR8y Signature of the challenge (Ry point) Private signatureS Signature of the challenge (S point) Private","title":"Inputs"},{"location":"protocol/main-circuits/#scope","text":"If oldState is genesis, verifies that userID is derived from the oldUserState (= genesis state). Performed using cutId() , cutState() and isEqual() templates newUserState is different than zero using isZero() comparator oldUserState and newUserState are different using isEqual() Verifies user's identity ownership using idOwnershipBySignature(nLevels) template. The message signed by the user is H(oldstate, newstate) where H is a Poseidon hash function executed inside the Poseidon(nInputs) template","title":"Scope"},{"location":"protocol/main-circuits/#circuit-specific-files-from-trusted-setup","text":"Final zkey circuit_final.zkey Verification Key verification_key.json WASM Witness Generator circuit.wasm","title":"Circuit Specific Files (From Trusted Setup)"},{"location":"protocol/main-circuits/#authentication","text":"Github Example of instantiation coming soon!","title":"authentication"},{"location":"protocol/main-circuits/#credentialatomicquerymtp","text":"Github Example of instantiation This circuit checks that an issuer has issued a claim for identity and validates the ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template Verifies the claim subject, the schema and the expiration time. Checks if the issuer claim exists in the issuer claims tree. Checks if the issuer claim is not revoked by an issuer. Checks if the issuer claim satisfies a query.","title":"credentialAtomicQueryMTP"},{"location":"protocol/main-circuits/#credentialatomicquerysig","text":"Github Example of instantiation This circuit checks that an issuer has issued a claim for identity and validates ownership of that identity in the following manner: Checks the identity ownership by idOwnershipBySignature template. Verifies the claim subject, the schema and the expiration time Checks if the issuer claim exists in the issuer claims tree. Verifies the claim signature by the issuer. Verifies if the issuer state matches with the one from the blockchain as the public input. Checks if the issuer claim satisfies a query.","title":"credentialAtomicQuerySig"},{"location":"protocol/querylanguage/","text":"Proof Query Language The specifications for the Proof Query Language are under development; consider it as a work-in-progress. Goal of the Query Language The initial idea is to have a generic circuit with the possibility to do a verification based on user-claims. As circuit setup is not a trivial task and especially, the trusted setup is a challenging thing for regular developers, we have to provide a simple generic query language based on the generic prebuilt circuits. The use of the Query Language should not be limited to specific atomic circuits; it must be extendable to other circuits too. Syntax The first version is set to support only these operations: >, <, =, in and notin . Later on, this list could be extended. Comparison Operations > greater than < less than = equal to notin - matches none of the values in - matches one of the values We have to use some syntax instead of raw signs as it will be inconvenient to use signs such as <, >, and = in JS. For example, $eq can be used instead of = , $gt can be used instead of >,and so on. Simple Operations { <field>: { $eq: <value> } } - equal { <field>: { $gt: <value> } } - greater than { <field>: { $lt: <value> } } - less than { <field>: { $nin: [<value>,<value>] } } { <field>: { $in: [<value>,<value>] } } For atomic claims, these operations could cover a lot of use-cases. Atomic Circuit The first implementation will cover only simple atomic verification of one field. It means that we will do query requests only to one data field. But we have to do all the required service verifications too such as check ownership, revocation, expiration, etc. We also need to include some additional attributes specific to the identity: Schemas List List of Trusted Issuers Challenge Example: A simple query { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } where: allowedIssuers : A list of issuers whom the verifier trusts. schema : A list of schemas that claims can use for proof generation. challenge : Used to verify that the provided proof belongs to the existing user session. req : A query request to the circuit. Example: Multiple requests in one query (WIP) { \"circuit_id\": \"atomicQueryMTP\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } }, { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"type\": \"KYCCountryOfResidenceCredential\", \"url\": \"ipfs://QmP8NrKqoBKjmKwMsC8pwBCBxXR2PhwSepwXx31gnJxAbP\" } ], \"challenge\": 12345678, \"req\": { \"country\": { \"$nin\": [ 840, 123 ] } } } ] } } A query circuit should accept query requests and perform the following mandatory verifications. Mandatory Verifications Verifying the claim Id ownership (proof is generated by identity, which is the subject of the claim). Verifying that the claim is not revoked. Verifying that the claim is not expired. Verifying that the identity key is not revoked. Query Apply query request Optional Check schema. Check the issuer of the claim. In some cases, schema and issuer are not important and therefore, we can have the possibility to omit these fields. List of Signals for Circuit Id Ownership Signals : signal input id; signal input hoIdenState; signal input hoClaimsTreeRoot; signal input authClaimMtp[IdOwnershipLevels]; signal input authClaim[8]; signal input hoRevTreeRoot; signal input authClaimNonRevMtp[IdOwnershipLevels]; signal input authClaimNonRevMtpNoAux; signal input authClaimNonRevMtpAuxHi; signal input authClaimNonRevMtpAuxHv; signal input hoRootsTreeRoot; signal input challenge; signal input challengeSignatureR8x; signal input challengeSignatureR8y; signal input challengeSignatureS; Claim Signals : signal input claimSchema; signal input claim[8]; signal input claimIssuanceMtp[IssuerLevels]; signal input claimIssuanceClaimsTreeRoot; signal input claimIssuanceRevTreeRoot; signal input claimIssuanceRootsTreeRoot; signal input claimIssuanceIdenState; signal input issuerID; Verify Claim Revocation Statuses : signal input claimNonRevMtp[IssuerLevels]; signal input claimNonRevMtpNoAux; signal input claimNonRevMtpAuxHi; signal input claimNonRevMtpAuxHv; signal input claimNonRevIssuerClaimsTreeRoot; signal input claimNonRevIssuerRevTreeRoot; signal input claimNonRevIssuerRootsTreeRoot; signal input claimNonRevIssuerState; Query Requests : signal input slotIndex; // index of field slot in the claim signal input value[valueArraySize]; // value for check signal input operator; // >,<, =,in, notin operations of CQL Public Inputs : challenge, id, hoIdenState, issuerID, claimIssuanceIdenState, claimSchema, slotIndex, operator, value, timestamp Proof Request Workflow Verifier (User) The verifier prepares a proof by requesting a query to the atomic circuit. Request : { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } The user parses a proof request and performs the necessary checks: The circuit is known. The schema is known. Claims by the specified issuer persist in the wallet. Get the issuer public state for key non-revocation proof. Prepare inputs for the circuit: Prepare ownership / claim / issuer / query inputs. Use schema to resolve field position in the claim. Generate ZK proof. Create proof-sharing response protocol message and send it to the verifier. Flow Diagram : Next Steps Make it possible to query multiple fields from the same schema, still, it is limited to four available slots, two indexes, and two values. With this combination, we can cover the more advanced use cases. Support more query operations. Fields combinations. Claim combinations. Represent JSON-LD document as a tree and store root as a claim. Extend verifications to this new schema. Do an atomic query verification. Extended query schema with multifield verifications from JSON-LD.","title":"Proof Query language"},{"location":"protocol/querylanguage/#proof-query-language","text":"The specifications for the Proof Query Language are under development; consider it as a work-in-progress.","title":"Proof Query Language"},{"location":"protocol/querylanguage/#goal-of-the-query-language","text":"The initial idea is to have a generic circuit with the possibility to do a verification based on user-claims. As circuit setup is not a trivial task and especially, the trusted setup is a challenging thing for regular developers, we have to provide a simple generic query language based on the generic prebuilt circuits. The use of the Query Language should not be limited to specific atomic circuits; it must be extendable to other circuits too.","title":"Goal of the Query Language"},{"location":"protocol/querylanguage/#syntax","text":"The first version is set to support only these operations: >, <, =, in and notin . Later on, this list could be extended. Comparison Operations > greater than < less than = equal to notin - matches none of the values in - matches one of the values We have to use some syntax instead of raw signs as it will be inconvenient to use signs such as <, >, and = in JS. For example, $eq can be used instead of = , $gt can be used instead of >,and so on. Simple Operations { <field>: { $eq: <value> } } - equal { <field>: { $gt: <value> } } - greater than { <field>: { $lt: <value> } } - less than { <field>: { $nin: [<value>,<value>] } } { <field>: { $in: [<value>,<value>] } } For atomic claims, these operations could cover a lot of use-cases.","title":"Syntax"},{"location":"protocol/querylanguage/#atomic-circuit","text":"The first implementation will cover only simple atomic verification of one field. It means that we will do query requests only to one data field. But we have to do all the required service verifications too such as check ownership, revocation, expiration, etc. We also need to include some additional attributes specific to the identity: Schemas List List of Trusted Issuers Challenge Example: A simple query { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } where: allowedIssuers : A list of issuers whom the verifier trusts. schema : A list of schemas that claims can use for proof generation. challenge : Used to verify that the provided proof belongs to the existing user session. req : A query request to the circuit. Example: Multiple requests in one query (WIP) { \"circuit_id\": \"atomicQueryMTP\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } }, { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"type\": \"KYCCountryOfResidenceCredential\", \"url\": \"ipfs://QmP8NrKqoBKjmKwMsC8pwBCBxXR2PhwSepwXx31gnJxAbP\" } ], \"challenge\": 12345678, \"req\": { \"country\": { \"$nin\": [ 840, 123 ] } } } ] } } A query circuit should accept query requests and perform the following mandatory verifications. Mandatory Verifications Verifying the claim Id ownership (proof is generated by identity, which is the subject of the claim). Verifying that the claim is not revoked. Verifying that the claim is not expired. Verifying that the identity key is not revoked. Query Apply query request Optional Check schema. Check the issuer of the claim. In some cases, schema and issuer are not important and therefore, we can have the possibility to omit these fields. List of Signals for Circuit Id Ownership Signals : signal input id; signal input hoIdenState; signal input hoClaimsTreeRoot; signal input authClaimMtp[IdOwnershipLevels]; signal input authClaim[8]; signal input hoRevTreeRoot; signal input authClaimNonRevMtp[IdOwnershipLevels]; signal input authClaimNonRevMtpNoAux; signal input authClaimNonRevMtpAuxHi; signal input authClaimNonRevMtpAuxHv; signal input hoRootsTreeRoot; signal input challenge; signal input challengeSignatureR8x; signal input challengeSignatureR8y; signal input challengeSignatureS; Claim Signals : signal input claimSchema; signal input claim[8]; signal input claimIssuanceMtp[IssuerLevels]; signal input claimIssuanceClaimsTreeRoot; signal input claimIssuanceRevTreeRoot; signal input claimIssuanceRootsTreeRoot; signal input claimIssuanceIdenState; signal input issuerID; Verify Claim Revocation Statuses : signal input claimNonRevMtp[IssuerLevels]; signal input claimNonRevMtpNoAux; signal input claimNonRevMtpAuxHi; signal input claimNonRevMtpAuxHv; signal input claimNonRevIssuerClaimsTreeRoot; signal input claimNonRevIssuerRevTreeRoot; signal input claimNonRevIssuerRootsTreeRoot; signal input claimNonRevIssuerState; Query Requests : signal input slotIndex; // index of field slot in the claim signal input value[valueArraySize]; // value for check signal input operator; // >,<, =,in, notin operations of CQL Public Inputs : challenge, id, hoIdenState, issuerID, claimIssuanceIdenState, claimSchema, slotIndex, operator, value, timestamp","title":"Atomic Circuit"},{"location":"protocol/querylanguage/#proof-request-workflow","text":"Verifier (User) The verifier prepares a proof by requesting a query to the atomic circuit. Request : { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } The user parses a proof request and performs the necessary checks: The circuit is known. The schema is known. Claims by the specified issuer persist in the wallet. Get the issuer public state for key non-revocation proof. Prepare inputs for the circuit: Prepare ownership / claim / issuer / query inputs. Use schema to resolve field position in the claim. Generate ZK proof. Create proof-sharing response protocol message and send it to the verifier. Flow Diagram :","title":"Proof Request Workflow"},{"location":"protocol/querylanguage/#next-steps","text":"Make it possible to query multiple fields from the same schema, still, it is limited to four available slots, two indexes, and two values. With this combination, we can cover the more advanced use cases. Support more query operations. Fields combinations. Claim combinations. Represent JSON-LD document as a tree and store root as a claim. Extend verifications to this new schema. Do an atomic query verification. Extended query schema with multifield verifications from JSON-LD.","title":"Next Steps"},{"location":"protocol/spec/","text":"Iden3 Protocol Specifications (Version 0) These specifications are under development and are being updated regularly. Consider it as a work-in-progress. Basis Glossary Issuer : An actor who makes a claim. Holder : An actor who receives a claim. Verifier : An actor who verifies if the content of a claim is issued by a specific identity and held by another specific identity. Credential : Data that is needed to prove that a claim is issued by a specific identity and held by another specific identity. This data is composed of a claim and a proof . Merkle Tree A Merkle tree (MT) or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every \"non-leaf\" node contains the cryptographic hash of its child nodes. The MTs used in the protocol have a few particularities: - Binary : Each node can only have two children. - Sparse and Deterministic : The contained data is indexed, and each data block is placed at the leaf that corresponds to that data block's index, so insert order doesn't influence the final Merkle tree Root. This also means that some nodes are empty. - ZK-friendly : The used hash function, poseidon , plays well with the zero-knowledge proofs (ZKP) used in different parts of the protocol. In order to ensure that these particularities are respected and to have a history of all the changes that occurred on different trees (without revealing the actual content stored in the leaves), the root of each MT is indirectly stored on the blockchain . The EVM-based blockchains are chosen for this purpose. The Merkle tree specification is defined in this document . In future, the MT implementation could be changed. Zero-knowledge Proof (ZKP) In cryptography, a zero-knowledge proof is a method by which one party (the prover) can prove to a second party (the verifier) that the prover knows a value x (that fulfills some constraints), without revealing any other information apart from the fact that s/he knows the value x. The technologies that implement these techniques are evolving rapidly. As of now, the protocol uses zkSNARKs Groth16, but in future, the zk protocol could be changed. zkSNARK stands for \"Zero-knowledge Succinct Non-interactive Argument of Knowledge\", and has the following properties: Non-interactive : With a single message (credential) from the prover, the verifier can verify the proof. This is good because it allows sending proofs to a smart contract that can verify these proofs immediately. Efficient Verification : It is computationally efficient to verify proofs, both in terms of the size and the operations. This is apt for the protocol because verification happens on the blockchain with its inherent costs. Heavy Proof Generation : Generating a proof is computationally very expensive and can be time-consuming even with powerful hardware. Setup : A pre-existing setup between the prover and the verifier is required for the construction of zkSNARKs. In order to ensure that the verifier cannot cheat, one has to be sure that the keys used for the setup have been destroyed. There are protocols to ensure that, resulting in a \"trusted setup\". Read more technical information about zkSNARKs in this article by Vitalik Buterin. Claims Definition A claim is a statement made by one identity about another identity or about itself. Each claim is composed of two parts: the index part and the value part. Claims are stored on the leaves of an MT. The index is hashed and is used to determine the leaf position where the value of the claim will be stored. A special transition validation function can be used to restrict how leaves are stored on the Merkle tree, i.e. make the MT append-only, (leaves can only be added and cannot be updated or deleted). Properties It is impossible to generate proof of a statement on behalf of an identity without its consent. Claims can be revoked. Claims can be updated by creating new versions. When a claim is revoked, no further versions can be made. Claims can be set to be updatable or not with a flag (See Claim Structure ). graph LR revoked(Revoked claim) no-claim-->v0 v0-->v1 v1-.->vN vN-->vN1 vN1-->revoked no-claim(No claim) v0(Claim v0) v1(Claim v1) vN(Claim vN) vN1(Claim vN+1) Claims can be verified. This means that it is possible to demonstrate cryptographically that a given claim is: Issued by a specific identity. Not revoked. Is of the last version of that claim if it is updatable. There are two types of claims regarding destination: Claims about identity's own properties. Example: Operational Key, Ethereum Address, etc. Claims about another identity's properties: (Another) Identity has a Property : Directional relation between an identity and a property (See Claim Structure : identity stored in hIndex, i_1). Property is Owned by (Another) Identity : Directional relation between a property and an identity (See Claim Structure : identity stored in hValue, v_1). NOTE: Some of these properties are only guaranteed by a transition validation function (explained above in this document). Structure h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0 Reliability of a Claim Content The correctness of what is said in a claim is not verifiable by a protocol since every identity is free to claim whatever it wants. Since it is possible to know which identity issued which claim, the trust/reputation that the issuer has can affect its credibility. However, the protocol can guarantee exclusivity: there cannot be two claims with the same index. So it is impossible that an identity claims that a property (index part of the claim) is linked to two different identities (value part of the claim) at the same time. Keys Keys are cryptographic elements that can be used to sign data. In a protocol, keys are used to authenticate certain interactions. These keys require the authorization of the identity (who owns these keys). This is done by adding a claim with a specific schema, linking the key(s) with the identity. This way, each time that a key is used for signing, the identity can (and must) prove the ownership of that key and the fact that the key is not revoked. Types of Keys Baby Jubjub: Used for authentication. This type of key is designed to be efficient while working with zkSNARKs. The Baby Jubjub Elliptic Curve specification is defined in this document . Identity Definition An identity is characterized by the claims that the identity has issued, and the claims that the identity has received from other identities. In other words, an identity is built by what the identity has said, and what others have said about the identity. Each claim that an identity issues can be cryptographically proved and verified, ensuring that the claim existed under identity at a certain timestamp. graph TD Root-->A Root-->B A-->C A-->D B-->E B-->F C-->G C-->H D-->I D-->J E-->K E-->L F-->M F-->N G[\"claim\"] H[\"claim\"] I[\"claim\"] J[\"claim\"] K[\"claim\"] L[\"claim\"] M[\"claim\"] N[\"claim\"] To accomplish this (and other properties covered in this document), identities are built by Merkle trees , where the claims are placed as the leaves, and the Root is published (indirectly through the identity state) on the blockchain. With this construction, the identities can issue, update, and revoke claims. The protocol construction is designed to enable zero-knowledge features. It means that the identities have the ability to prove the ownership of the properties of the claims in issued and received claims and verify that a particular claim is not revoked. Genesis ID Description Each identity has a unique identifier that is determined by the initial identity state (hash of its Merkle Tree Roots). This identifier is called Genesis ID , under which the initial claims are placed (those that are contained in the initial state of the identity). For the initial implementation of the protocol, the Genesis Claims Tree will contain at least a claim of authorization of the Operational Key that allows operation in the name of identity. While an identity does not add, update or revoke claims after the Genesis State, its identity state does not need to be published on the blockchain, and the Genesis Claims can be verified directly against the Genesis ID . This is because the Genesis ID is built by the Merkle Root that holds those claims. NOTE: The Genesis ID is calculated with the Identity State as a hash of the Genesis Claims Tree Root, an empty Revocation Tree Root and an empty Roots Tree Root. Identifier Format An Identifier is determined by its identity type and the Genesis Identity State (also called the Genesis ID ). This is built by creating a Merkle Tree that holds the initial state claims, calculating its root, and hashing it together with an empty Revocation Tree Root & an empty Roots Tree Root. Then we take the first 27 bytes of this result and add to it 2 bytes at the beginning (to specify the identity type), and 2 bytes at the end (for checksum).Thus, in total, an identifier is a byte array of 31 bytes, encoded in base58. An identity type specifies the specifications that an identity follows (such as the hash function used by the identity). In this way, when the hash function changes, the identifiers of the identities will also change, allowing us to identify the type of identity. Identifier Structure : - ID (genesis): Base58 [ type | genesis_state | checksum ] - type : 2 bytes specifying the type - genesis_state : First 27 bytes from the identity state (using the Genesis Claim Merkle tree) - checksum : Addition (with overflow) of all the ID bytes Little Endian 16 bits ( [ type | genesis_state ] ) Identity State The identity states are published on the blockchain under the identifier, anchoring the state of the identity with the timestamp when it is published. In this way, the claims of the identity can be proved against the anchored identity state at a certain timestamp. To transition from one state to the other, identities follow the transition functions. The identity states can be published on the blockchain in one of the two ways: directly performing the transaction to publish the root or indirectly using a Relay. The Genesis State is the initial state of any identity, and does not need to be published on the blockchain, as the claims under it can be verified against the identifier itself (that contains that identity state). Identity State Transition Function The ITF (Identity State Transition Function) is verified each time a state is updated. This ensures that the identity follows the protocol while updating. An Identity Merkle tree is a sparse binary tree that allows only the addition of the leaves (no edition or deletion). Adding new claims, updating them through versions and revoking need to be done according to the ITF . To ensure this, we use zero-knowledge proofs in a way that when an identity is publishing a new state to the smart contract, it also sends a zero-knowledge proof ( \u03c0 ), proving that the \u03d5 is satisfied following the ITF . In this way, all the identity states published on the blockchain are validated to be following the protocol. NOTE: In the initial version of the implementation, there will be no checks to verify that the trees are append-only in the smart contract. This is due to the fact that complex computations are required to generate the zk proofs for multiple claim additions, (a requirement for scalability). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/stateTransition.circom Identity Ownership We prove the identity ownership inside a zkSNARK proof. This means that the user can generate a zk-proof that s/he knows a private key corresponding to the operational key for authorization claim added to the Claims Tree, without revealing the claim and its position. This is coded inside a circom circuit, which can be used in other circuits (such as the id state update circuit). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/lib/idOwnershipBySignature.circom Identity Key Rotation An identity can self-issue and revoke many private keys and the corresponding claims of the type operational key authorization , enabling key rotation. To support verification of such claims, an identity state should be publicly available on the blockchain. An identity can publish the state to the blockchain directly or via the Relay. Any private key for which a corresponding claim exists in the Identity Claims Tree and does not exist in the Identity Revocation Tree, can be used to create a zero-knowledge proof for valid credentials. Such proof should pass verification by a verifier as it is able to check the latest identity state in the blockchain. In the same way, any valid and non-revoked identity private key can be used to create a valid zk proof for the Identity State Transition Function. NOTE: An identity may lose some privacy while disclosing its state to a verifier, which can track all the proofs of the same identity in that manner. However, this issue can be mitigated if the identity state is published to the blockchain via a Relay. In such a case, only the Relay state needs to be disclosed to a verifier. Identity Revocation When an identity revokes all the claims of the type operational key authorization , it is considered revoked as this identity can no longer create proofs. Interaction between Identity and Claims Identity State Update The Identity State Update is the procedure used to update information about what this identity has claimed. This involves three different actions: - Add a claim. - Update a claim (by incrementing the version and changing the claim value part). - Revoke a claim. Definitions IdS : Identity State ClT : Claims Tree ClR : Claims Tree Root ReT : Revocation Tree ReR : Revocation Tree Root RoT : Roots Tree RoR : Roots Tree Root The IdS (Identity State) is calculated by concatenating the roots of the three user trees: - IdS : H(ClR || ReR || RoR) where H is the Hash function defined by the Identity Type (for example, Poseidon). All trees are SMT (sparse Merkle trees) and use the hash function defined by the Identity Type. - Leaves in ClT (Claims Tree) are claims ((4 + 4) * 253 bits = 253 bytes) See Claim Structure - Leaves in ReT (Revocation Tree) are Revocation Nonce + Version (64 bits + 32 bits = 12 bytes) Revocation Tree Leaf: leaf: [ 64 bits ] revocation nonce [ 32 bits ] version [157 bits ] 0 Leaves in RoT (Roots Tree) are tree roots (from the Claims Tree) (253 bits = 32 bytes) Roots Tree Leaf: leaf: [253 bits ] tree root Identity State Diagram for Direct Identity As seen in the diagram, only the IdS is stored on the blockchain. In order to save the stored bytes on the blockchain, it is desirable that only one \"hash\" representing the current state of the Identity is stored on the smart contract. This one \"hash\" is the IdS (Identity State), which is linked to a timestamp and a block on the blockchain. All the public data must be made available for any holder so that they can build fresh Merkle tree proofs of both the ReT and RoT . This allows the holder to: Prove recent non-revocation / \"current\" version without interaction with the issuer. Hide a particular ClR from all the other ClR s to avoid an issuer from discovering a claim hidden behind a zk proof. For this purpose, ClR is added to RoR . The place and the method to access the publicly available data are specified in the Identities State smart contract. Two possible initial options are: IPFS, by adding a link to an IPNS address (example: ipfs://ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd ), which contains a standardized structure of the data. HTTPS, by adding a link to an HTTPS endpoint (example: https://kyc.iden3.io/api/v1/public-state/aabbccdd ), which offers the data following a standardized API. Publish Claims The first step in publishing a claim involves adding a new leaf to the ClT , which updates the identity ClR . Claims can be optionally published in batches, adding more than one leaf to the ClT in a single transaction. After the ClT has been updated, the identity must follow an Identity State Update so that anyone is able to verify the newly added claims. This involves adding the new ClR to the RoT , which in turn will update the RoR . Post that, the new IdS is calculated and through a transaction it is updated in the Identities State Smart Contract (from now on, referred to as \"the smart contract\") on the blockchain. Once the updated IdS is in the smart contract, anyone can verify the validity of the newly added claims. The procedure to update the IdS in the smart contract can be achieved with the following criteria: - Bad scalability (no batch), good privacy, and correctness : The identity uploads the new IdS to the smart contract with proof of a correct transition from the old IdS to the new one. Only one claim is added to the ClT in the transition. - Good scalability (batch), good privacy, and correctness : Same as before, but many claims are added (batch) in the transition (with a single proof for all newly added claims) - Good scalability (batch), good privacy but no correctness : The identity uploads the new IdS to the smart contract, without proving correctness on the transition. The criteria for correctness are as follows: - Revocation of a claim cannot be reverted. - Updatable claims are only updated with increasing versions, and only one version is valid at a time. To have or to not have the guarantee of the correctness is specified in the Identity Type so that any verifier knows about the guarantees provided by the protocol for the issuer claims. NOTE: Good scalability refers to the verification process and the costs related to the smart contract. Batching with zkSNARKs can have a high computation load on the prover. Revocation Tree Sometimes, it is desirable for an identity to invalidate a statement made through a claim. For regular claims, this involves revoking (a process that is ideally irreversible) and allows any verifier to be aware that an already published claim is made invalid by the issuer's identity. Similarly, for updatable claims, there must be a mechanism to invalidate old versions when a new one is published. Since confirming the current validity of a claim is a parallel process to confirming that a claim was published at some point, the \"current validation\" process can be separated. Separating these two processes allows a design in which the ClT (Claim Tree) remains private, but the revocation/version information is public, allowing a holder to generate a fresh proof of the \"current validity\" without requesting access to the private ClT . To achieve this, every Identity has a ClT (Claim Tree) and a separate ReT (Revocation Tree). While the Claim Tree would be private and only the root public, the revocation tree would be entirely public. The roots of both the trees ( ClT and ReT ) are linked via the IdS (Identity State) which is published in the smart contract. The Revocation Tree could be published in IPFS or other public storage systems. Proving that a claim is valid (and thus not revoked/updated) consists of two proofs: - Prove that the claim was issued at some time t (this proof is generated once by the issuer and uses a IdS - ClR at time t stored in the smart contract). - Prove that the claim has not been revoked/updated recently (this proof is generated by the holder with a recent ReR (Revocation Tree Root) by querying the public ReT (Revocation Tree), and verified against a recent IdS ). Revoke Claims To prevent revealing anything about the content of the claim in the ReT , the claim contains a revocation nonce in the value part, which is added as a leaf in the ReT to revocate the claim. To prevent reversing revocation of a claim, the ReT needs to follow some transition rules like ClT , enforced by a zk proof (for space and verification efficiency). Apart from the revoking procedure, there is a method to define the validity of a claim based on expiration, by explicitly setting an expiration date in the claim (See Claim Structure ). Revoking and Expiration are compatible methods to invalidate claims. Update Claims To update a claim, a new claim is added to the ClT with an increased version value in the index position of the claim (notice that the previous version of the claim is not touched). Then, a leaf is added to the ReT containing the revocation nonce and the highest invalid version (that is, all the claims with that nonce and version equal or lower to the one in the leaf are invalid). This means that when a claim is updated, the same revocation nonce is used in the claim. To prevent downgrading the version of a claim, and forcing to have only one valid updatable claim at a time, the ReT needs to follow the transition rules (like the ClT does) enforced by a zk proof (for space and verification efficiency). Updating and revoking are compatible methods to invalidate claims: an updatable claim can be revoked, which means no future (or past) updates would be valid. In case when a claim needs to be revoked completely, without the possibility to update, the highest version and the revocation nonce should be added to the ReT . Prove Claims (Credentials) Nomenclature - MTP: Merkle Tree Proof. The list of siblings in a path from a leaf to the root. Prove that a Claim was Issued at Time t Requires proving a link between the claim and IdS_t (Identity State at time t) published in the smart contract. This proof requires: Claim t MTP Claim -> ClR_t RoR_t (Roots Tree at time t) ReR_t (Revocation Tree Root at time t) IdS_t where t is any time. Prove that the Claim is Currently Valid Prove that the Claim Hasn't Been Revoked Recently Requires proving the inexistence of a link between the claim revocation nonce and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the smart contract. This proof requires: Claim (Nonce) t (Recent Time) MTP !Nonce -> ReR_t ClR_t RoR_t IdS_t [1] The verifier needs to decide a time span to define how recent the IdS_t used in the proof needs to be. Using the current IdS instead of recent could lead to data races, so it is better to select an IdS that is no more than X hours old. Proof of Last Version This is very similar to proving that a claim has not been recently revoked except that in this case, not only the nonce in the claim is checked, but also the version. - Requires proving the inexistence of a link between the claim revocation nonce + version and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the smart contract. This proof requires: - Claim (Nonce, Version) - t - MTP !(Nonce, Version) -> ReR_t - ClR_t - RoR_t - IdS_t Where t is a recent time. Proof of Non-Expiration A claim can be made expirable by setting an expiration flag in the options and specifying an expiration date in the Unix timestamp format in the corresponding claim value part (see Claim Format ). Zero-knowledge Proof of Valid Credentials A zero-knowledge proof allows hiding some information about a claim while proving that it was issued by a particular identity and that it is currently valid. The same checks mentioned in the previous sections are performed: - Prove that a claim was issued at least at time t. - Prove that the claim is currently valid. In the proof that shows \"that a claim was issued at time at least t\", there is an additional part that is added to hide a particular IdS_t1 that is used (in order to hide the claim from the issuer. See Appendix Title 2). The proof then requires: - Claim - t - MTP Claim -> ClR_t1 - RoR_t1 (Roots Tree at time t1) - ReR_t1 (Revocation Tree Root at time t1) - IdS_t1 - MTP ClR_t1 -> RoR_t2 - ClR_t2 (Claims Tree Root at time t2) - ReR_t2 (Revocation Tree Root at time t2) - IdS_t2 Where t1 is any time and t2 is the recent time. The full circuit can be found at: https://github.com/iden3/circuits/tree/master/circuits/lib Identity Communication Issuer - Holder (Credential Request Procedure) The same procedure works for already issued claims and the new claims: - The issuer has issued a claim linking a property to the holder, and the holder requests the credential of the issued claim. - The holder requests the issue of a new claim linking a property to the holder. NOTE: In HTTP, use polling to resolve the \"Future\". In asynchronous messaging, request the resolution of the \"Future\" and wait for the reply. Direct Claims sequenceDiagram Holder->>IssuerServer: req. Credential + auth? IssuerServer->>IssuerServer: Auto/Manual check IssuerServer->>IssuerServer: Add Claim to MT IssuerServer->>Holder: Future(Credential) IssuerServer->>SmartContract: Publish Root SmartContract->>IssuerServer: Ok Holder->>IssuerServer: Poll(Future(Credential)) IssuerServer->>Holder: Credential Indirect Claims sequenceDiagram Holder->>IssuerClient: req. Credential IssuerClient->>IssuerClient: Auto/Manual check IssuerClient->>IssuerClient: Add Claim to MT IssuerClient->>Relay: req. Credential (SetRoot) Relay->>Relay: Add Claim to MT Relay->>IssuerClient: Future(Credential1) IssuerClient->>Holder: Credential0, Future(Credential1) Relay->>SmartContract: Publish Root SmartContract->>Relay: Ok Holder->>Relay: Poll(Future(Credential1)) Relay->>Holder: Credential Holder - Verifier Verifier requests a claim (or in general, a proof that involves some claims). Holder shows a proof of the claim (or in general, a proof that involves some claims) to the verifier. sequenceDiagram participant A Exchange_SC->>Exchange_SC: define CR with CRL A->>Exchange_SC: get CR Exchange_SC->>A: CR A->>A: build proof using Claim DB A->>Exchange_SC: proof Exchange_SC->>Exchange_SC: validate Exchange_SC->>Exchange_SC: action Exchange_SC->>A: result <!--","title":"Iden3 protocol specs"},{"location":"protocol/spec/#iden3-protocol-specifications-version-0","text":"These specifications are under development and are being updated regularly. Consider it as a work-in-progress.","title":"Iden3 Protocol Specifications (Version 0)"},{"location":"protocol/spec/#basis","text":"","title":"Basis"},{"location":"protocol/spec/#glossary","text":"Issuer : An actor who makes a claim. Holder : An actor who receives a claim. Verifier : An actor who verifies if the content of a claim is issued by a specific identity and held by another specific identity. Credential : Data that is needed to prove that a claim is issued by a specific identity and held by another specific identity. This data is composed of a claim and a proof .","title":"Glossary"},{"location":"protocol/spec/#merkle-tree","text":"A Merkle tree (MT) or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every \"non-leaf\" node contains the cryptographic hash of its child nodes. The MTs used in the protocol have a few particularities: - Binary : Each node can only have two children. - Sparse and Deterministic : The contained data is indexed, and each data block is placed at the leaf that corresponds to that data block's index, so insert order doesn't influence the final Merkle tree Root. This also means that some nodes are empty. - ZK-friendly : The used hash function, poseidon , plays well with the zero-knowledge proofs (ZKP) used in different parts of the protocol. In order to ensure that these particularities are respected and to have a history of all the changes that occurred on different trees (without revealing the actual content stored in the leaves), the root of each MT is indirectly stored on the blockchain . The EVM-based blockchains are chosen for this purpose. The Merkle tree specification is defined in this document . In future, the MT implementation could be changed.","title":"Merkle Tree"},{"location":"protocol/spec/#zero-knowledge-proof-zkp","text":"In cryptography, a zero-knowledge proof is a method by which one party (the prover) can prove to a second party (the verifier) that the prover knows a value x (that fulfills some constraints), without revealing any other information apart from the fact that s/he knows the value x. The technologies that implement these techniques are evolving rapidly. As of now, the protocol uses zkSNARKs Groth16, but in future, the zk protocol could be changed. zkSNARK stands for \"Zero-knowledge Succinct Non-interactive Argument of Knowledge\", and has the following properties: Non-interactive : With a single message (credential) from the prover, the verifier can verify the proof. This is good because it allows sending proofs to a smart contract that can verify these proofs immediately. Efficient Verification : It is computationally efficient to verify proofs, both in terms of the size and the operations. This is apt for the protocol because verification happens on the blockchain with its inherent costs. Heavy Proof Generation : Generating a proof is computationally very expensive and can be time-consuming even with powerful hardware. Setup : A pre-existing setup between the prover and the verifier is required for the construction of zkSNARKs. In order to ensure that the verifier cannot cheat, one has to be sure that the keys used for the setup have been destroyed. There are protocols to ensure that, resulting in a \"trusted setup\". Read more technical information about zkSNARKs in this article by Vitalik Buterin.","title":"Zero-knowledge Proof (ZKP)"},{"location":"protocol/spec/#claims","text":"","title":"Claims"},{"location":"protocol/spec/#definition","text":"A claim is a statement made by one identity about another identity or about itself. Each claim is composed of two parts: the index part and the value part. Claims are stored on the leaves of an MT. The index is hashed and is used to determine the leaf position where the value of the claim will be stored. A special transition validation function can be used to restrict how leaves are stored on the Merkle tree, i.e. make the MT append-only, (leaves can only be added and cannot be updated or deleted).","title":"Definition"},{"location":"protocol/spec/#properties","text":"It is impossible to generate proof of a statement on behalf of an identity without its consent. Claims can be revoked. Claims can be updated by creating new versions. When a claim is revoked, no further versions can be made. Claims can be set to be updatable or not with a flag (See Claim Structure ). graph LR revoked(Revoked claim) no-claim-->v0 v0-->v1 v1-.->vN vN-->vN1 vN1-->revoked no-claim(No claim) v0(Claim v0) v1(Claim v1) vN(Claim vN) vN1(Claim vN+1) Claims can be verified. This means that it is possible to demonstrate cryptographically that a given claim is: Issued by a specific identity. Not revoked. Is of the last version of that claim if it is updatable. There are two types of claims regarding destination: Claims about identity's own properties. Example: Operational Key, Ethereum Address, etc. Claims about another identity's properties: (Another) Identity has a Property : Directional relation between an identity and a property (See Claim Structure : identity stored in hIndex, i_1). Property is Owned by (Another) Identity : Directional relation between a property and an identity (See Claim Structure : identity stored in hValue, v_1). NOTE: Some of these properties are only guaranteed by a transition validation function (explained above in this document).","title":"Properties"},{"location":"protocol/spec/#structure","text":"h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"Structure"},{"location":"protocol/spec/#reliability-of-a-claim-content","text":"The correctness of what is said in a claim is not verifiable by a protocol since every identity is free to claim whatever it wants. Since it is possible to know which identity issued which claim, the trust/reputation that the issuer has can affect its credibility. However, the protocol can guarantee exclusivity: there cannot be two claims with the same index. So it is impossible that an identity claims that a property (index part of the claim) is linked to two different identities (value part of the claim) at the same time.","title":"Reliability of a Claim Content"},{"location":"protocol/spec/#keys","text":"Keys are cryptographic elements that can be used to sign data. In a protocol, keys are used to authenticate certain interactions. These keys require the authorization of the identity (who owns these keys). This is done by adding a claim with a specific schema, linking the key(s) with the identity. This way, each time that a key is used for signing, the identity can (and must) prove the ownership of that key and the fact that the key is not revoked.","title":"Keys"},{"location":"protocol/spec/#types-of-keys","text":"Baby Jubjub: Used for authentication. This type of key is designed to be efficient while working with zkSNARKs. The Baby Jubjub Elliptic Curve specification is defined in this document .","title":"Types of Keys"},{"location":"protocol/spec/#identity","text":"","title":"Identity"},{"location":"protocol/spec/#definition_1","text":"An identity is characterized by the claims that the identity has issued, and the claims that the identity has received from other identities. In other words, an identity is built by what the identity has said, and what others have said about the identity. Each claim that an identity issues can be cryptographically proved and verified, ensuring that the claim existed under identity at a certain timestamp. graph TD Root-->A Root-->B A-->C A-->D B-->E B-->F C-->G C-->H D-->I D-->J E-->K E-->L F-->M F-->N G[\"claim\"] H[\"claim\"] I[\"claim\"] J[\"claim\"] K[\"claim\"] L[\"claim\"] M[\"claim\"] N[\"claim\"] To accomplish this (and other properties covered in this document), identities are built by Merkle trees , where the claims are placed as the leaves, and the Root is published (indirectly through the identity state) on the blockchain. With this construction, the identities can issue, update, and revoke claims. The protocol construction is designed to enable zero-knowledge features. It means that the identities have the ability to prove the ownership of the properties of the claims in issued and received claims and verify that a particular claim is not revoked.","title":"Definition"},{"location":"protocol/spec/#genesis-id","text":"","title":"Genesis ID"},{"location":"protocol/spec/#description","text":"Each identity has a unique identifier that is determined by the initial identity state (hash of its Merkle Tree Roots). This identifier is called Genesis ID , under which the initial claims are placed (those that are contained in the initial state of the identity). For the initial implementation of the protocol, the Genesis Claims Tree will contain at least a claim of authorization of the Operational Key that allows operation in the name of identity. While an identity does not add, update or revoke claims after the Genesis State, its identity state does not need to be published on the blockchain, and the Genesis Claims can be verified directly against the Genesis ID . This is because the Genesis ID is built by the Merkle Root that holds those claims. NOTE: The Genesis ID is calculated with the Identity State as a hash of the Genesis Claims Tree Root, an empty Revocation Tree Root and an empty Roots Tree Root.","title":"Description"},{"location":"protocol/spec/#identifier-format","text":"An Identifier is determined by its identity type and the Genesis Identity State (also called the Genesis ID ). This is built by creating a Merkle Tree that holds the initial state claims, calculating its root, and hashing it together with an empty Revocation Tree Root & an empty Roots Tree Root. Then we take the first 27 bytes of this result and add to it 2 bytes at the beginning (to specify the identity type), and 2 bytes at the end (for checksum).Thus, in total, an identifier is a byte array of 31 bytes, encoded in base58. An identity type specifies the specifications that an identity follows (such as the hash function used by the identity). In this way, when the hash function changes, the identifiers of the identities will also change, allowing us to identify the type of identity. Identifier Structure : - ID (genesis): Base58 [ type | genesis_state | checksum ] - type : 2 bytes specifying the type - genesis_state : First 27 bytes from the identity state (using the Genesis Claim Merkle tree) - checksum : Addition (with overflow) of all the ID bytes Little Endian 16 bits ( [ type | genesis_state ] )","title":"Identifier Format"},{"location":"protocol/spec/#identity-state","text":"The identity states are published on the blockchain under the identifier, anchoring the state of the identity with the timestamp when it is published. In this way, the claims of the identity can be proved against the anchored identity state at a certain timestamp. To transition from one state to the other, identities follow the transition functions. The identity states can be published on the blockchain in one of the two ways: directly performing the transaction to publish the root or indirectly using a Relay. The Genesis State is the initial state of any identity, and does not need to be published on the blockchain, as the claims under it can be verified against the identifier itself (that contains that identity state).","title":"Identity State"},{"location":"protocol/spec/#identity-state-transition-function","text":"The ITF (Identity State Transition Function) is verified each time a state is updated. This ensures that the identity follows the protocol while updating. An Identity Merkle tree is a sparse binary tree that allows only the addition of the leaves (no edition or deletion). Adding new claims, updating them through versions and revoking need to be done according to the ITF . To ensure this, we use zero-knowledge proofs in a way that when an identity is publishing a new state to the smart contract, it also sends a zero-knowledge proof ( \u03c0 ), proving that the \u03d5 is satisfied following the ITF . In this way, all the identity states published on the blockchain are validated to be following the protocol. NOTE: In the initial version of the implementation, there will be no checks to verify that the trees are append-only in the smart contract. This is due to the fact that complex computations are required to generate the zk proofs for multiple claim additions, (a requirement for scalability). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/stateTransition.circom","title":"Identity State Transition Function"},{"location":"protocol/spec/#identity-ownership","text":"We prove the identity ownership inside a zkSNARK proof. This means that the user can generate a zk-proof that s/he knows a private key corresponding to the operational key for authorization claim added to the Claims Tree, without revealing the claim and its position. This is coded inside a circom circuit, which can be used in other circuits (such as the id state update circuit). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/lib/idOwnershipBySignature.circom","title":"Identity Ownership"},{"location":"protocol/spec/#identity-key-rotation","text":"An identity can self-issue and revoke many private keys and the corresponding claims of the type operational key authorization , enabling key rotation. To support verification of such claims, an identity state should be publicly available on the blockchain. An identity can publish the state to the blockchain directly or via the Relay. Any private key for which a corresponding claim exists in the Identity Claims Tree and does not exist in the Identity Revocation Tree, can be used to create a zero-knowledge proof for valid credentials. Such proof should pass verification by a verifier as it is able to check the latest identity state in the blockchain. In the same way, any valid and non-revoked identity private key can be used to create a valid zk proof for the Identity State Transition Function. NOTE: An identity may lose some privacy while disclosing its state to a verifier, which can track all the proofs of the same identity in that manner. However, this issue can be mitigated if the identity state is published to the blockchain via a Relay. In such a case, only the Relay state needs to be disclosed to a verifier.","title":"Identity Key Rotation"},{"location":"protocol/spec/#identity-revocation","text":"When an identity revokes all the claims of the type operational key authorization , it is considered revoked as this identity can no longer create proofs.","title":"Identity Revocation"},{"location":"protocol/spec/#interaction-between-identity-and-claims","text":"","title":"Interaction between Identity and Claims"},{"location":"protocol/spec/#identity-state-update","text":"The Identity State Update is the procedure used to update information about what this identity has claimed. This involves three different actions: - Add a claim. - Update a claim (by incrementing the version and changing the claim value part). - Revoke a claim.","title":"Identity State Update"},{"location":"protocol/spec/#definitions","text":"IdS : Identity State ClT : Claims Tree ClR : Claims Tree Root ReT : Revocation Tree ReR : Revocation Tree Root RoT : Roots Tree RoR : Roots Tree Root The IdS (Identity State) is calculated by concatenating the roots of the three user trees: - IdS : H(ClR || ReR || RoR) where H is the Hash function defined by the Identity Type (for example, Poseidon). All trees are SMT (sparse Merkle trees) and use the hash function defined by the Identity Type. - Leaves in ClT (Claims Tree) are claims ((4 + 4) * 253 bits = 253 bytes) See Claim Structure - Leaves in ReT (Revocation Tree) are Revocation Nonce + Version (64 bits + 32 bits = 12 bytes) Revocation Tree Leaf: leaf: [ 64 bits ] revocation nonce [ 32 bits ] version [157 bits ] 0 Leaves in RoT (Roots Tree) are tree roots (from the Claims Tree) (253 bits = 32 bytes) Roots Tree Leaf: leaf: [253 bits ] tree root Identity State Diagram for Direct Identity As seen in the diagram, only the IdS is stored on the blockchain. In order to save the stored bytes on the blockchain, it is desirable that only one \"hash\" representing the current state of the Identity is stored on the smart contract. This one \"hash\" is the IdS (Identity State), which is linked to a timestamp and a block on the blockchain. All the public data must be made available for any holder so that they can build fresh Merkle tree proofs of both the ReT and RoT . This allows the holder to: Prove recent non-revocation / \"current\" version without interaction with the issuer. Hide a particular ClR from all the other ClR s to avoid an issuer from discovering a claim hidden behind a zk proof. For this purpose, ClR is added to RoR . The place and the method to access the publicly available data are specified in the Identities State smart contract. Two possible initial options are: IPFS, by adding a link to an IPNS address (example: ipfs://ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd ), which contains a standardized structure of the data. HTTPS, by adding a link to an HTTPS endpoint (example: https://kyc.iden3.io/api/v1/public-state/aabbccdd ), which offers the data following a standardized API.","title":"Definitions"},{"location":"protocol/spec/#publish-claims","text":"The first step in publishing a claim involves adding a new leaf to the ClT , which updates the identity ClR . Claims can be optionally published in batches, adding more than one leaf to the ClT in a single transaction. After the ClT has been updated, the identity must follow an Identity State Update so that anyone is able to verify the newly added claims. This involves adding the new ClR to the RoT , which in turn will update the RoR . Post that, the new IdS is calculated and through a transaction it is updated in the Identities State Smart Contract (from now on, referred to as \"the smart contract\") on the blockchain. Once the updated IdS is in the smart contract, anyone can verify the validity of the newly added claims. The procedure to update the IdS in the smart contract can be achieved with the following criteria: - Bad scalability (no batch), good privacy, and correctness : The identity uploads the new IdS to the smart contract with proof of a correct transition from the old IdS to the new one. Only one claim is added to the ClT in the transition. - Good scalability (batch), good privacy, and correctness : Same as before, but many claims are added (batch) in the transition (with a single proof for all newly added claims) - Good scalability (batch), good privacy but no correctness : The identity uploads the new IdS to the smart contract, without proving correctness on the transition. The criteria for correctness are as follows: - Revocation of a claim cannot be reverted. - Updatable claims are only updated with increasing versions, and only one version is valid at a time. To have or to not have the guarantee of the correctness is specified in the Identity Type so that any verifier knows about the guarantees provided by the protocol for the issuer claims. NOTE: Good scalability refers to the verification process and the costs related to the smart contract. Batching with zkSNARKs can have a high computation load on the prover.","title":"Publish Claims"},{"location":"protocol/spec/#revocation-tree","text":"Sometimes, it is desirable for an identity to invalidate a statement made through a claim. For regular claims, this involves revoking (a process that is ideally irreversible) and allows any verifier to be aware that an already published claim is made invalid by the issuer's identity. Similarly, for updatable claims, there must be a mechanism to invalidate old versions when a new one is published. Since confirming the current validity of a claim is a parallel process to confirming that a claim was published at some point, the \"current validation\" process can be separated. Separating these two processes allows a design in which the ClT (Claim Tree) remains private, but the revocation/version information is public, allowing a holder to generate a fresh proof of the \"current validity\" without requesting access to the private ClT . To achieve this, every Identity has a ClT (Claim Tree) and a separate ReT (Revocation Tree). While the Claim Tree would be private and only the root public, the revocation tree would be entirely public. The roots of both the trees ( ClT and ReT ) are linked via the IdS (Identity State) which is published in the smart contract. The Revocation Tree could be published in IPFS or other public storage systems. Proving that a claim is valid (and thus not revoked/updated) consists of two proofs: - Prove that the claim was issued at some time t (this proof is generated once by the issuer and uses a IdS - ClR at time t stored in the smart contract). - Prove that the claim has not been revoked/updated recently (this proof is generated by the holder with a recent ReR (Revocation Tree Root) by querying the public ReT (Revocation Tree), and verified against a recent IdS ).","title":"Revocation Tree"},{"location":"protocol/spec/#revoke-claims","text":"To prevent revealing anything about the content of the claim in the ReT , the claim contains a revocation nonce in the value part, which is added as a leaf in the ReT to revocate the claim. To prevent reversing revocation of a claim, the ReT needs to follow some transition rules like ClT , enforced by a zk proof (for space and verification efficiency). Apart from the revoking procedure, there is a method to define the validity of a claim based on expiration, by explicitly setting an expiration date in the claim (See Claim Structure ). Revoking and Expiration are compatible methods to invalidate claims.","title":"Revoke Claims"},{"location":"protocol/spec/#update-claims","text":"To update a claim, a new claim is added to the ClT with an increased version value in the index position of the claim (notice that the previous version of the claim is not touched). Then, a leaf is added to the ReT containing the revocation nonce and the highest invalid version (that is, all the claims with that nonce and version equal or lower to the one in the leaf are invalid). This means that when a claim is updated, the same revocation nonce is used in the claim. To prevent downgrading the version of a claim, and forcing to have only one valid updatable claim at a time, the ReT needs to follow the transition rules (like the ClT does) enforced by a zk proof (for space and verification efficiency). Updating and revoking are compatible methods to invalidate claims: an updatable claim can be revoked, which means no future (or past) updates would be valid. In case when a claim needs to be revoked completely, without the possibility to update, the highest version and the revocation nonce should be added to the ReT .","title":"Update Claims"},{"location":"protocol/spec/#prove-claims-credentials","text":"Nomenclature - MTP: Merkle Tree Proof. The list of siblings in a path from a leaf to the root.","title":"Prove Claims (Credentials)"},{"location":"protocol/spec/#prove-that-a-claim-was-issued-at-time-t","text":"Requires proving a link between the claim and IdS_t (Identity State at time t) published in the smart contract. This proof requires: Claim t MTP Claim -> ClR_t RoR_t (Roots Tree at time t) ReR_t (Revocation Tree Root at time t) IdS_t where t is any time.","title":"Prove that a Claim was Issued at Time t"},{"location":"protocol/spec/#prove-that-the-claim-is-currently-valid","text":"","title":"Prove that the Claim is Currently Valid"},{"location":"protocol/spec/#prove-that-the-claim-hasnt-been-revoked-recently","text":"Requires proving the inexistence of a link between the claim revocation nonce and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the smart contract. This proof requires: Claim (Nonce) t (Recent Time) MTP !Nonce -> ReR_t ClR_t RoR_t IdS_t [1] The verifier needs to decide a time span to define how recent the IdS_t used in the proof needs to be. Using the current IdS instead of recent could lead to data races, so it is better to select an IdS that is no more than X hours old.","title":"Prove that the Claim Hasn't Been Revoked Recently"},{"location":"protocol/spec/#proof-of-last-version","text":"This is very similar to proving that a claim has not been recently revoked except that in this case, not only the nonce in the claim is checked, but also the version. - Requires proving the inexistence of a link between the claim revocation nonce + version and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the smart contract. This proof requires: - Claim (Nonce, Version) - t - MTP !(Nonce, Version) -> ReR_t - ClR_t - RoR_t - IdS_t Where t is a recent time.","title":"Proof of Last Version"},{"location":"protocol/spec/#proof-of-non-expiration","text":"A claim can be made expirable by setting an expiration flag in the options and specifying an expiration date in the Unix timestamp format in the corresponding claim value part (see Claim Format ).","title":"Proof of Non-Expiration"},{"location":"protocol/spec/#zero-knowledge-proof-of-valid-credentials","text":"A zero-knowledge proof allows hiding some information about a claim while proving that it was issued by a particular identity and that it is currently valid. The same checks mentioned in the previous sections are performed: - Prove that a claim was issued at least at time t. - Prove that the claim is currently valid. In the proof that shows \"that a claim was issued at time at least t\", there is an additional part that is added to hide a particular IdS_t1 that is used (in order to hide the claim from the issuer. See Appendix Title 2). The proof then requires: - Claim - t - MTP Claim -> ClR_t1 - RoR_t1 (Roots Tree at time t1) - ReR_t1 (Revocation Tree Root at time t1) - IdS_t1 - MTP ClR_t1 -> RoR_t2 - ClR_t2 (Claims Tree Root at time t2) - ReR_t2 (Revocation Tree Root at time t2) - IdS_t2 Where t1 is any time and t2 is the recent time. The full circuit can be found at: https://github.com/iden3/circuits/tree/master/circuits/lib","title":"Zero-knowledge Proof of Valid Credentials"},{"location":"protocol/spec/#identity-communication","text":"","title":"Identity Communication"},{"location":"protocol/spec/#issuer-holder-credential-request-procedure","text":"The same procedure works for already issued claims and the new claims: - The issuer has issued a claim linking a property to the holder, and the holder requests the credential of the issued claim. - The holder requests the issue of a new claim linking a property to the holder. NOTE: In HTTP, use polling to resolve the \"Future\". In asynchronous messaging, request the resolution of the \"Future\" and wait for the reply.","title":"Issuer - Holder (Credential Request Procedure)"},{"location":"protocol/spec/#direct-claims","text":"sequenceDiagram Holder->>IssuerServer: req. Credential + auth? IssuerServer->>IssuerServer: Auto/Manual check IssuerServer->>IssuerServer: Add Claim to MT IssuerServer->>Holder: Future(Credential) IssuerServer->>SmartContract: Publish Root SmartContract->>IssuerServer: Ok Holder->>IssuerServer: Poll(Future(Credential)) IssuerServer->>Holder: Credential","title":"Direct Claims"},{"location":"protocol/spec/#indirect-claims","text":"sequenceDiagram Holder->>IssuerClient: req. Credential IssuerClient->>IssuerClient: Auto/Manual check IssuerClient->>IssuerClient: Add Claim to MT IssuerClient->>Relay: req. Credential (SetRoot) Relay->>Relay: Add Claim to MT Relay->>IssuerClient: Future(Credential1) IssuerClient->>Holder: Credential0, Future(Credential1) Relay->>SmartContract: Publish Root SmartContract->>Relay: Ok Holder->>Relay: Poll(Future(Credential1)) Relay->>Holder: Credential","title":"Indirect Claims"},{"location":"protocol/spec/#holder-verifier","text":"Verifier requests a claim (or in general, a proof that involves some claims). Holder shows a proof of the claim (or in general, a proof that involves some claims) to the verifier. sequenceDiagram participant A Exchange_SC->>Exchange_SC: define CR with CRL A->>Exchange_SC: get CR Exchange_SC->>A: CR A->>A: build proof using Claim DB A->>Exchange_SC: proof Exchange_SC->>Exchange_SC: validate Exchange_SC->>Exchange_SC: action Exchange_SC->>A: result <!--","title":"Holder - Verifier"},{"location":"protocol/template-circuits/","text":"Template Circuits The template circuits are not are not used independently inside Iden3 protocols but rather as a building blocks inside the main circuits. Note: not all the templates are described here but only a few of them. Check Iden3 Circuits and Iden3 Circomlib to see all the templates. idOwnershipBySignature Github Inputs Input Description userState Identity State of the prover userClaimsTreeRoot Prover's Claims Tree Root userAuthClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree userAuthClaim[8] Prover's Auth Claim userRevTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value userRootsTreeRoot Prover's Roots Tree Root challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point) Scope Verifies that the signature was performed by the key contained in the authClaim and performs further verification on the auth claim using the VerifyAuthClaimAndSignature(nLevels) template The state generated by hashing the three roots should match the expected state from the blockchain (or be the genesis state) using the checkIdenStateMatchesRoots() template VerifyAuthClaimAndSignature Github Inputs Input Description claimsTreeRoot Prover's Claims Tree Root authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree authClaim[8] Prover's Auth Claim revTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point) Scope The schema hash of the claim must match the expected AUTH_SCHEMA_HASH (hardcoded inside the circuit). Verification performed using the verifyCredentialSchema() template The authClaim exists inside the claims tree root by using the checkClaimExists() template The authClaim hasn't been revoked, namely verifies that the authClaim is not included inside the revocation tree root, using the checkClaimNotRevoked() template Verifies that the signature on the challenge has been performed by the publickey contained in the authClaim using the checkDataSignatureWithPubKeyInClaim() template","title":"Template Circuits"},{"location":"protocol/template-circuits/#template-circuits","text":"The template circuits are not are not used independently inside Iden3 protocols but rather as a building blocks inside the main circuits. Note: not all the templates are described here but only a few of them. Check Iden3 Circuits and Iden3 Circomlib to see all the templates.","title":"Template Circuits"},{"location":"protocol/template-circuits/#idownershipbysignature","text":"Github","title":"idOwnershipBySignature"},{"location":"protocol/template-circuits/#inputs","text":"Input Description userState Identity State of the prover userClaimsTreeRoot Prover's Claims Tree Root userAuthClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree userAuthClaim[8] Prover's Auth Claim userRevTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value userRootsTreeRoot Prover's Roots Tree Root challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)","title":"Inputs"},{"location":"protocol/template-circuits/#scope","text":"Verifies that the signature was performed by the key contained in the authClaim and performs further verification on the auth claim using the VerifyAuthClaimAndSignature(nLevels) template The state generated by hashing the three roots should match the expected state from the blockchain (or be the genesis state) using the checkIdenStateMatchesRoots() template","title":"Scope"},{"location":"protocol/template-circuits/#verifyauthclaimandsignature","text":"Github","title":"VerifyAuthClaimAndSignature"},{"location":"protocol/template-circuits/#inputs_1","text":"Input Description claimsTreeRoot Prover's Claims Tree Root authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree authClaim[8] Prover's Auth Claim revTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)","title":"Inputs"},{"location":"protocol/template-circuits/#scope_1","text":"The schema hash of the claim must match the expected AUTH_SCHEMA_HASH (hardcoded inside the circuit). Verification performed using the verifyCredentialSchema() template The authClaim exists inside the claims tree root by using the checkClaimExists() template The authClaim hasn't been revoked, namely verifies that the authClaim is not included inside the revocation tree root, using the checkClaimNotRevoked() template Verifies that the signature on the challenge has been performed by the publickey contained in the authClaim using the checkDataSignatureWithPubKeyInClaim() template","title":"Scope"},{"location":"protocol/zklogin/","text":"Server-side Login (ZKP Login) Introduction Iden3 is a Self-Sovereign Identity (SSI) solution that allows users to leverage their pre-existing validated identities. With SSI, they are able to prove they are who they claim to be based on the zero-knowledge proofs. One of the direct applications of the iden3 technology is to allow web applications to reuse these identities for logging into their portals. Login Workflow Login Workflow In a simple example, an application requests a user identifier; this is done through the zero-knowledge proof (zk proof) generation. The server generates an authentication request. Auth request { \"type\": \"https://iden3-communication.io/authorization-request/v1\", \"data\": { \"callbackUrl\": \"https://test.com/callbackurl\", \"audience\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\", \"scope\": [ { \"circuit_id\": \"auth\", \"type\": \"zeroknowledge\", \"rules\": { \"challenge\": 12345 } } ] } } Shown above is an example of an authorization request. Scope field is a set of objects that describes an array of proofs that must be generated on a user device and presented later. Each scope member has a unique definition of a circuit that must be used and a set of rules (public inputs) that must be applied. This message can be delivered to a user through different communication channels: QR code, email, deep-linking, etc. On scanning, mobile needs to implement the following: Parse the authorization request and understand which proof handler it should use. Resolve the verifier identifier if required. Generate proofs using a specific handler. It can be a signature proof or a zero-knowledge proof. Prepare an authentication response message. On mobile, a user generates the ZK proof using auth circuit that will prove identity ownership, and send the response to the callback URL. Auth response { \"type\": \"https://iden3-communication.io/authorization-response/v1\", \"data\": { \"scope\": [ { \"type\": \"zeroknowledge\", \"circuit_id\": \"auth\", \"pub_signals\": [ \"371135506535866236563870411357090963344408827476607986362864968105378316288\", \"12345\", \"16751774198505232045539489584666775489135471631443877047826295522719290880931\" ], \"proof_data\": { \"pi_a\": [ \"8286889681087188684411199510889276918687181609540093440568310458198317956303\", \"20120810686068956496055592376395897424117861934161580256832624025185006492545\", \"1\" ], \"pi_b\": [ [ \"8781021494687726640921078755116610543888920881180197598360798979078295904948\", \"19202155147447713148677957576892776380573753514701598304555554559013661311518\" ], [ \"15726655173394887666308034684678118482468533753607200826879522418086507576197\", \"16663572050292231627606042532825469225281493999513959929720171494729819874292\" ], [ \"1\", \"0\" ] ], \"pi_c\": [ \"9723779257940517259310236863517792034982122114581325631102251752415874164616\", \"3242951480985471018890459433562773969741463856458716743271162635077379852479\", \"1\" ], \"protocol\": \"groth16\" } } ] } } The client, after receiving an authorization response, performs the verification process: Verification with zero-knowledge proof. Extraction of metadata (auth and circuit-specific). Verification of the user identity states. Verification of the circuit's public inputs (e.g. issuer state). Authentication based on Zero-knowledge Proof ZK proof is based on the Circom 2.0 language. Auth Circuit Repository: auth The circuit verifies that the user is the owner of the identity and his auth key is not revoked in the provided user state. Prerequisites The identity wallet should be installed. Integration Back-end Generate Auth Request request := auth.CreateAuthorizationRequest(\"<challenge>\",\"<verifier identity|app-url>\", \"<callbackURI>\") // create auth request Validate Auth Request // unpack raw message message, err := packer.Unpack(msgBytes) // call library to verify zkp proofs err = auth.VerifyProofs(message) // extract metadata token, err := auth.ExtractMetadata(message) // verify state stateInfo, err := token.VerifyState(ctx.Background(),\"< rpc url >\", \"< state contract address >\") In future releases of the auth library, the verification procedure will be simplified and optimized for a verifier. Front-end On the front-end, you need to embed a button to initiate the login process. After this button is pressed, the front-end makes a request to the back-end to generate an authentication request and displays it in the QR code. When a user scans the QR code, the phone generates a zk proof and sends this proof to the call-back URL from the QR code. Currently, we are working on the js-iden3-auth library. Tutorial: A Simple Go Application For this, we need a web server with two endpoints: GET /sign-in should return auth request POST /call-back endpoint to receive a callback request from the phone and validate the same Let us write a simple web server: func main() { http.HandleFunc(\"/sign-in\", signIn) http.HandleFunc(\"/call-back\", callBack) http.ListenAndServe(\":8001\", nil) } func signIn(w http.ResponseWriter, req *http.Request) { } func callBack(w http.ResponseWriter, req *http.Request) { } Auth Package Add the authorization package to the project. go get https://github.com/iden3/go-iden3-auth Sign-in To generate a zk auth request, we need a callback URL where we will receive a response from the mobile application along with an authentication response and the verifier's identity. The go-iden3-auth library contains a method for generating the authentication request. [Description] func CreateAuthorizationRequest(challenge int64, aud, callbackURL string) *types.AuthorizationMessageRequest Now, we are ready to generate the auth request: const CallBackUrl = \"http:localhost:8001/call-back\" const VerifierIdentity = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" func signIn(w http.ResponseWriter, req *http.Request) { request := auth.CreateAuthorizationRequest(10, VerifierIdentity, callBackURI) msgBytes, _ := json.Marshal(request) // error handling ommited for simplification w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) w.Write(msgBytes) } Callback When we receive a callback request with a zk response, to validate, we need to take the following actions: Validate zk proof and make sure that the proof is valid. Validate identity's state on-chain so as to verify that the user identity state is valid and his/her auth keys are not revoked. First, let\u2019s validate the zk proof. For this, we have the following function: func VerifyProofs(message types.Message) (err error) But before we can call it, we need to unpack raw bytes to a message. Packer can be used to process the encrypted message for future releases. p := &packer.PlainMessagePacker{} // Unpack msg message, _ := p.Unpack(msgBytes) // verify zkp proofErr := auth.VerifyProofs(message) Now that the zk proof is verified, we can check the identity's status on-chain. First, we need access the RPC URL and the address of the identity's smart contract: const rpc = \"https://polygon-mumbai.infura.io/v3/<your-token>\" const IdentityContract = \"0x3e95a7B12e8905E01126E1beA3F1a52D1624A725\" Before we can verify a state, we need to extract the metadata and then verify it on-chain. token, _:= auth.ExtractMetadata(message) // verify match identifier with the state on chain stateInfo, err := token.VerifyState(ctx, rpc, IdentityContract) Verification Procedure Zero-knowledge Proof Verification Groth16 proofs are now supported by the auth library. Verification keys for the circuits can be referred to from the library. In the future, they can be resolved from the circuit registries. Extraction of Metadata Each circuit has a schema of its public inputs that links the public signal name to its position in the resulting array. This allows extracting user identifiers and challenges from the proof for authentication. Other signals are added to the user token (scope field) as attributes of a specific circuit. The circuit's public signal schemas are known by this library or can be retrieved from a registry. Verification of User Identity States The blockchain verification algorithm is used to: Get state from the blockchain (address of the id state contract and URL must be provided by the caller of the library): Empty State is Returned : It indicates that the identity state has not been updated or the updated state has not been published. We need to compare the id with the state. If they are different, it is not the genesis state of the identity and it is not valid. Non-empty State is Returned and Equals to the State Provided in Proof : This indicates that the user state is new and we work with the latest user state. Non-empty State is Returned and is not Equal to the State Provided in Proof : Gets the time of the state transition. The verification party can make a decision if it can accept this state based on that time frame. Accept or reject the provided state (The verification party makes this decision). Verification of Circuit's Public Signals This verification includes the following: 1. Check if the issuer states of the provided claim proofs are published on the blockchain (same as for identity state). 2. Check the query signals so that the claim schema and the specific values can be verified.","title":"Login protocol"},{"location":"protocol/zklogin/#server-side-login-zkp-login","text":"","title":"Server-side Login (ZKP Login)"},{"location":"protocol/zklogin/#introduction","text":"Iden3 is a Self-Sovereign Identity (SSI) solution that allows users to leverage their pre-existing validated identities. With SSI, they are able to prove they are who they claim to be based on the zero-knowledge proofs. One of the direct applications of the iden3 technology is to allow web applications to reuse these identities for logging into their portals.","title":"Introduction"},{"location":"protocol/zklogin/#login-workflow","text":"Login Workflow In a simple example, an application requests a user identifier; this is done through the zero-knowledge proof (zk proof) generation. The server generates an authentication request. Auth request { \"type\": \"https://iden3-communication.io/authorization-request/v1\", \"data\": { \"callbackUrl\": \"https://test.com/callbackurl\", \"audience\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\", \"scope\": [ { \"circuit_id\": \"auth\", \"type\": \"zeroknowledge\", \"rules\": { \"challenge\": 12345 } } ] } } Shown above is an example of an authorization request. Scope field is a set of objects that describes an array of proofs that must be generated on a user device and presented later. Each scope member has a unique definition of a circuit that must be used and a set of rules (public inputs) that must be applied. This message can be delivered to a user through different communication channels: QR code, email, deep-linking, etc. On scanning, mobile needs to implement the following: Parse the authorization request and understand which proof handler it should use. Resolve the verifier identifier if required. Generate proofs using a specific handler. It can be a signature proof or a zero-knowledge proof. Prepare an authentication response message. On mobile, a user generates the ZK proof using auth circuit that will prove identity ownership, and send the response to the callback URL. Auth response { \"type\": \"https://iden3-communication.io/authorization-response/v1\", \"data\": { \"scope\": [ { \"type\": \"zeroknowledge\", \"circuit_id\": \"auth\", \"pub_signals\": [ \"371135506535866236563870411357090963344408827476607986362864968105378316288\", \"12345\", \"16751774198505232045539489584666775489135471631443877047826295522719290880931\" ], \"proof_data\": { \"pi_a\": [ \"8286889681087188684411199510889276918687181609540093440568310458198317956303\", \"20120810686068956496055592376395897424117861934161580256832624025185006492545\", \"1\" ], \"pi_b\": [ [ \"8781021494687726640921078755116610543888920881180197598360798979078295904948\", \"19202155147447713148677957576892776380573753514701598304555554559013661311518\" ], [ \"15726655173394887666308034684678118482468533753607200826879522418086507576197\", \"16663572050292231627606042532825469225281493999513959929720171494729819874292\" ], [ \"1\", \"0\" ] ], \"pi_c\": [ \"9723779257940517259310236863517792034982122114581325631102251752415874164616\", \"3242951480985471018890459433562773969741463856458716743271162635077379852479\", \"1\" ], \"protocol\": \"groth16\" } } ] } } The client, after receiving an authorization response, performs the verification process: Verification with zero-knowledge proof. Extraction of metadata (auth and circuit-specific). Verification of the user identity states. Verification of the circuit's public inputs (e.g. issuer state).","title":"Login Workflow"},{"location":"protocol/zklogin/#authentication-based-on-zero-knowledge-proof","text":"ZK proof is based on the Circom 2.0 language. Auth Circuit Repository: auth The circuit verifies that the user is the owner of the identity and his auth key is not revoked in the provided user state.","title":"Authentication based on Zero-knowledge Proof"},{"location":"protocol/zklogin/#prerequisites","text":"The identity wallet should be installed.","title":"Prerequisites"},{"location":"protocol/zklogin/#integration","text":"","title":"Integration"},{"location":"protocol/zklogin/#back-end","text":"Generate Auth Request request := auth.CreateAuthorizationRequest(\"<challenge>\",\"<verifier identity|app-url>\", \"<callbackURI>\") // create auth request Validate Auth Request // unpack raw message message, err := packer.Unpack(msgBytes) // call library to verify zkp proofs err = auth.VerifyProofs(message) // extract metadata token, err := auth.ExtractMetadata(message) // verify state stateInfo, err := token.VerifyState(ctx.Background(),\"< rpc url >\", \"< state contract address >\") In future releases of the auth library, the verification procedure will be simplified and optimized for a verifier.","title":"Back-end"},{"location":"protocol/zklogin/#front-end","text":"On the front-end, you need to embed a button to initiate the login process. After this button is pressed, the front-end makes a request to the back-end to generate an authentication request and displays it in the QR code. When a user scans the QR code, the phone generates a zk proof and sends this proof to the call-back URL from the QR code. Currently, we are working on the js-iden3-auth library.","title":"Front-end"},{"location":"protocol/zklogin/#tutorial-a-simple-go-application","text":"For this, we need a web server with two endpoints: GET /sign-in should return auth request POST /call-back endpoint to receive a callback request from the phone and validate the same Let us write a simple web server: func main() { http.HandleFunc(\"/sign-in\", signIn) http.HandleFunc(\"/call-back\", callBack) http.ListenAndServe(\":8001\", nil) } func signIn(w http.ResponseWriter, req *http.Request) { } func callBack(w http.ResponseWriter, req *http.Request) { }","title":"Tutorial: A Simple Go Application"},{"location":"protocol/zklogin/#auth-package","text":"Add the authorization package to the project. go get https://github.com/iden3/go-iden3-auth","title":"Auth Package"},{"location":"protocol/zklogin/#sign-in","text":"To generate a zk auth request, we need a callback URL where we will receive a response from the mobile application along with an authentication response and the verifier's identity. The go-iden3-auth library contains a method for generating the authentication request. [Description] func CreateAuthorizationRequest(challenge int64, aud, callbackURL string) *types.AuthorizationMessageRequest Now, we are ready to generate the auth request: const CallBackUrl = \"http:localhost:8001/call-back\" const VerifierIdentity = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" func signIn(w http.ResponseWriter, req *http.Request) { request := auth.CreateAuthorizationRequest(10, VerifierIdentity, callBackURI) msgBytes, _ := json.Marshal(request) // error handling ommited for simplification w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) w.Write(msgBytes) }","title":"Sign-in"},{"location":"protocol/zklogin/#callback","text":"When we receive a callback request with a zk response, to validate, we need to take the following actions: Validate zk proof and make sure that the proof is valid. Validate identity's state on-chain so as to verify that the user identity state is valid and his/her auth keys are not revoked. First, let\u2019s validate the zk proof. For this, we have the following function: func VerifyProofs(message types.Message) (err error) But before we can call it, we need to unpack raw bytes to a message. Packer can be used to process the encrypted message for future releases. p := &packer.PlainMessagePacker{} // Unpack msg message, _ := p.Unpack(msgBytes) // verify zkp proofErr := auth.VerifyProofs(message) Now that the zk proof is verified, we can check the identity's status on-chain. First, we need access the RPC URL and the address of the identity's smart contract: const rpc = \"https://polygon-mumbai.infura.io/v3/<your-token>\" const IdentityContract = \"0x3e95a7B12e8905E01126E1beA3F1a52D1624A725\" Before we can verify a state, we need to extract the metadata and then verify it on-chain. token, _:= auth.ExtractMetadata(message) // verify match identifier with the state on chain stateInfo, err := token.VerifyState(ctx, rpc, IdentityContract)","title":"Callback"},{"location":"protocol/zklogin/#verification-procedure","text":"","title":"Verification Procedure"},{"location":"protocol/zklogin/#zero-knowledge-proof-verification","text":"Groth16 proofs are now supported by the auth library. Verification keys for the circuits can be referred to from the library. In the future, they can be resolved from the circuit registries.","title":"Zero-knowledge Proof Verification"},{"location":"protocol/zklogin/#extraction-of-metadata","text":"Each circuit has a schema of its public inputs that links the public signal name to its position in the resulting array. This allows extracting user identifiers and challenges from the proof for authentication. Other signals are added to the user token (scope field) as attributes of a specific circuit. The circuit's public signal schemas are known by this library or can be retrieved from a registry.","title":"Extraction of Metadata"},{"location":"protocol/zklogin/#verification-of-user-identity-states","text":"The blockchain verification algorithm is used to: Get state from the blockchain (address of the id state contract and URL must be provided by the caller of the library): Empty State is Returned : It indicates that the identity state has not been updated or the updated state has not been published. We need to compare the id with the state. If they are different, it is not the genesis state of the identity and it is not valid. Non-empty State is Returned and Equals to the State Provided in Proof : This indicates that the user state is new and we work with the latest user state. Non-empty State is Returned and is not Equal to the State Provided in Proof : Gets the time of the state transition. The verification party can make a decision if it can accept this state based on that time frame. Accept or reject the provided state (The verification party makes this decision).","title":"Verification of User Identity States"},{"location":"protocol/zklogin/#verification-of-circuits-public-signals","text":"This verification includes the following: 1. Check if the issuer states of the provided claim proofs are published on the blockchain (same as for identity state). 2. Check the query signals so that the claim schema and the specific values can be verified.","title":"Verification of Circuit's Public Signals"},{"location":"publications/publications/","text":"Publications Research Papers Baby Jubjub Elliptic Curve ( pdf ) EdDSA For Baby Jubjub Elliptic Curve with MiMC-7 Hash ( pdf ) 4-bit Window Pedersen Hash on the Baby Jubjub Elliptic Curve ( pdf ) Sparse Merkle Trees ( pdf ) Videos Introduction to Iden3 Circom and SnarkJS Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy Websnarks - DappCon 2019 Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020 Slides Introduction to Iden3 Circom and SnarkJS Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020","title":"Publications"},{"location":"publications/publications/#publications","text":"","title":"Publications"},{"location":"publications/publications/#research-papers","text":"Baby Jubjub Elliptic Curve ( pdf ) EdDSA For Baby Jubjub Elliptic Curve with MiMC-7 Hash ( pdf ) 4-bit Window Pedersen Hash on the Baby Jubjub Elliptic Curve ( pdf ) Sparse Merkle Trees ( pdf )","title":"Research Papers"},{"location":"publications/publications/#videos","text":"Introduction to Iden3 Circom and SnarkJS Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy Websnarks - DappCon 2019 Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020","title":"Videos"},{"location":"publications/publications/#slides","text":"Introduction to Iden3 Circom and SnarkJS Scalable Distributed Identity Infrastructure Using Zero-knowledge Proofs to Guarantee Privacy Big ZkSNARK Circuits for Zk-rollups with Circom - EthCC 2020","title":"Slides"},{"location":"publications/pdfs/test/","text":"","title":"Test"},{"location":"services/libraries/","text":"Iden3 Protocol Libraries Crypto Library ( go-iden3-crypto ) Implementation of Poseidon Hash and Baby JubJub Eliptic Curve Merkle Tree SQL Library ( go-merkletree-sql ) Implementation of Sparse Merkle Tree Core Library ( go-iden3-core ) Identity Core Primitives Circuits ( circuits ) Identity Circuits Go Circuits ( go-circuits ) Library for Transforming Go-core Primitives to JSON Inputs for Identity Circuits Prover Server ( prover-server ) Wrapper on SnarkJSfor Zk-proof Generation Authorization Library ( go-iden3-auth ) Library for Authentication with Zk-proof Verification","title":"Iden3 Protocol Libraries"},{"location":"services/libraries/#iden3-protocol-libraries","text":"Crypto Library ( go-iden3-crypto ) Implementation of Poseidon Hash and Baby JubJub Eliptic Curve Merkle Tree SQL Library ( go-merkletree-sql ) Implementation of Sparse Merkle Tree Core Library ( go-iden3-core ) Identity Core Primitives Circuits ( circuits ) Identity Circuits Go Circuits ( go-circuits ) Library for Transforming Go-core Primitives to JSON Inputs for Identity Circuits Prover Server ( prover-server ) Wrapper on SnarkJSfor Zk-proof Generation Authorization Library ( go-iden3-auth ) Library for Authentication with Zk-proof Verification","title":"Iden3 Protocol Libraries"},{"location":"services/login-protocol/","text":"Login Protocol Introduction The login protocol is based on the signature protocol, in which a user signs a packet using an authorized kSign key. For the login case, the user desires to assert a particular identity (an Ethereum address in this case) to a server so that s/he is allowed access to the service while being identified. Assumptions Secure connection between wallet and server. Secure connection between web client and server. Wallet authenticates the server in the connection. Web client authenticates the server in the connection. What is Required? Server authenticates the Ethereum address and Ethereum name from the wallet. The user transfers the authentication from the wallet to the web client. Protocol Flow Challenges contain a cryptographic nonce and have a timeout that indicates the validity of the nonce in the challenge. A signed challenge with a timed out nonce must be rejected by the server. The server must store a list of the nonces that have not timed out and have not been signed yet to guarantee the freshness. A cryptographic nonce must be generated securely and must be long enough to avoid collisions (we use 256 bits). Signature Protocol v0.1: Specifications A signature may be requested as follows: { header: { typ: iden3.sig.v0_1 } body: { type: TYPE data: DATA } } Depending upon the signature protocol specifications, a user generates a packet that may contain data from the signature request or can be created from scratch. The packet contains a header and a payload, is serialized, and signed following the JWS standard . Usually, the form is filled in by the user, and data is copied from a request. The structures of the data and the form in the payload are specified by the type (what is being signed) in the payload. The rest of the elements are specified by the typ (signature packet) in the header. JWS_PAYLOAD = { type: TYPE data: DATA form: FORM ksign: str # ksing public key in compressed form proofKSing: proofClaim # Proof of authorize k sign claim (which contains the public key in compressed form) } JWS_HEADER = { typ: iden3.sig.v0_1 iss: str # Ethereum Address iat: uint # issued at time, unix timestamp exp: uint # expiration time, unix timestamp alg: ? # algorithm } JWS_SIGN(JWS_HEADER, JWS_PAYLOAD) Each signature request type has a view representation for the user, where the data and form are presented. Some of the values may be hidden from the user when necessary, but only if doing so doesn\u2019t compromise the security of the user. In the request view, the user has the ability to pick some elements of the form . ksign is the compressed public key of a secp256k ECDSA key pair. The proofKSing contains a KSign Authorize Claim for a secp256k public key. As JWS_HEADER.alg , we will use a custom algorithm (not defined in the JWS standard): \u201cEK256K1\u201d, which is ECDSA with secp256k1 curve and keccak as a hash function, the same signature algorithm configuration as is used in Ethereum. Auxiliary Data Structures proofClaim: { signature: signature # Relay root + date signed by relay date: uint leaf: claim proofs: proofClaimPartial[] } proofClaimPartial: { mtp0: mtp # merkle tree proof of leaf existence mtp1: mtp # merkle tree proof of leaf non-existence root: key # merkle tree root aux: nil | { ver: uint, era: uint, idAddr: str } # Necessary data to construct SetRootClaim from root } Usually, the relay returns the proofClaim data structure to prove that a claim is valid and is in the Merkle tree. Identity Assertion v0.1: Specifications payload: type: iden3.iden_assert.v0_1 data: { challenge: nonce # 256 bits in base64 timeout: uint # seconds origin: str # domain } form: { ethName: str # ethereumName proofAssignName: proofClaim # proof of claim Assign Name for ethName } A session id, if required, can be computed from the challenge. This session id can be used to link the communication between the web service and the wallet service. view: type: Identity Assertion data: { origin: str # domain } form: { ethName: str # ethereum name } Algorithms In the following sections, we will show an overview of the steps of the algorithms used for verification of the proofs and signatures used in the login protocol. The algorithms below consider the case in which there is a single trusted entity (identified by relayPk ) that acts as a relay and as a domain name server. Signature Verification Algorithm VerifySignedPacket(jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsHeader.typ is 'iden3.sig.v0_1' 2. Verify jwsHeader.alg is 'EK256K1' 3. Verify that jwsHeader.iat <= now() < jwsHeader.exp 4. Verify that jwsPayload.ksign is in jwsPayload.proofKSign.leaf 5. Verify that jwsHeader.iss is in jwsPayload.proofKSign 6. Verify that signature of JWS(jwsHeader, jwsPayload) by jwsPayload.ksign is signature 7. VerifyProofOfClaim(jwsPayload.proofKSign, relayPk) In step 4 above, we verify that the ksign used to sign the packet is authorized by the user and is identified by the jwsHeader.iss Ethereum address. Iden Assert Verification Algorithm VerifyIdenAssertV01(nonceDB, origin, jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsPayload.type is 'iden3.iden_assert.v0_1' 2. Verify jwsPayload.data.origin is origin 3. Verify jwsPayload.data.challenge is in nonceDB and hasn't expired, delete it 4. Verify that jwsHeader.iss and jwsPayload.form.ethName are in jwsPayload.proofAssignName.leaf 5. VerifyProofOfClaim(jwsPayload.form.ethName, relayPk) Proof of Claim Verification VerifyProofOfClaim(p, relayPk): 1. Verify signature of p.proofs[-1].root by relayPk is p.signature let leaf = p.leaf 2. loop for each proof in p.proofs: 2.1 Verify proof.mtp0 is existence proof 2.2 Verify proof.mtp0 with leaf and proof.root 2.3 Verify proof.mtp1 is non-existence proof 2.4 Verify proof.mtp1 with ClaimIncrementVersion(leaf) and proof.root leaf = NewClaimSetRootClaim(p.root, p.aux.ver, p.aux.era, p.aux.ethAddr) iden3js Protocols Login (Identity Assertion) Wallet Service + + | signatureRequest | | <-------------------------------------+ | | | | +---+ | | | | | |sign packet | | | | | <---+ | | signedPacket | | +-------------------------------------> | | | | +---+ | | verify | | | signedPacket| | | | | | +---> | | | | ok | | <-------------------------------------+ | | | | | | | + + Read the login protocol specifications here: Define New NonceDB const nonceDB = new iden3.protocols.NonceDB(); Generate New Request for Identity Assert Input nonceDB : NonceDB class object origin : Domain of the emitter of the request timeout : Unix time format, valid until that date. For example, we can use 2 minutes ( 2*60 seconds) Output signatureRequest : Object {.sourceCode .js} const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2*60); The nonce of the signatureRequest can be accessed as: const nonce = signatureRequest.body.data.challenge; // nonce is the string containing the nonce value We can add auxiliar data to the nonce in the nonceDB only one time: const added = nodeDB.addAuxToNonce(nonce, auxdata); // added is a bool confirming if the aux data had been added. Sign Packet input signatureRequest : object generated in the newRequestIdenAssert function userAddr : Ethereum address of the user who signs the data packet ethName : name assigned to the userAddr proofOfEthName : proofOfClaim of the ethName kc : iden3.KeyContainer object ksign : KOperational authorized for the userAddr proofOfKSign : proofOfClaim of the ksign expirationTime : Unix time format, signature will be valid until that date output signedPacket : String {.sourceCode .js} const expirationTime = unixtime + (3600 * 60); const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr, ethName, proofOfEthName, kc, ksign, proofOfKSign, expirationTime); Verify Signed Packet input nonceDB : NonceDB class object origin : Domain of the emitter of the request signedPacket : Object generated in the signIdenAssertV01 function output nonce : Nonce object of the signedPacket that has been deleted from the nonceDB when the signedPacket is verified. If the verification fails, the nonce will be undefined. {.sourceCode .js} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); Rationale In the following sections, you will find references to a few protocols on which our login protocol relies or takes inspiration from. Signature Format Use JSON to encode the object that will be signed. JSON Signing Formats https://medium.facilelogin.com/json-message-signing-alternatives-897f90d411c JSON Web Signature (JWS) Doesn\u2019t need canonicalization Allows signing arbitrary data (not only JSON) Widely used JSON Cleartext Signature (JCS) Concise Binary Object Representation (CBOR) Object Signing https://matrix.org/docs/spec/appendices.html#signing-json Matrix JSON Signing Allows having multiple signatures with different protocols for a single JSON Possible attacks See WebAuth API, FIDO Threat Analysis References https://en.wikipedia.org/wiki/OpenID https://en.wikipedia.org/wiki/OpenID_Connect https://en.wikipedia.org/wiki/IndieAuth https://fidoalliance.org/how-fido-works/ WebAuth API https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API https://w3c.github.io/webauthn/ https://www.w3.org/TR/webauthn/ https://www.webauthn.io/ (Demo) FIDO Security Guarantees and How They are Achieved: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#relation-between-measures-and-goals FIDO Threat Analysis and Mitigations: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#threat-analysis Currently (2018-01-08) there\u2019s no support for iOS (Safari): https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#Browser_compatibility Criticism: https://www.scip.ch/en/?labs.20180424 Example Code of Server Verification: https://github.com/duo-labs/webauthn/blob/fa6cd954884baf24fc5a51656ce21c1a1ef574bc/main.go#L336 https://w3c.github.io/webauthn/#verifying-assertion Appendix The FIDO Protocols: Security Goals [SG-1] Strong User Authentication : Authenticate (recognize) a user and/or a device to a relying party with high (cryptographic) strength. [SG-2] Credential Guessing Resilience : Provide robust protection against eavesdroppers, e.g. be resilient to physical observation, resilient to targeted impersonation, and resilient to throttled and unthrottled guessing. [SG-3] Credential Disclosure Resilience : Be resilient to phishing attacks and real-time phishing attacks including resilience to online attacks by adversaries that are able to actively manipulate network traffic. [SG-4] Unlinkablity : Protect the protocol conversation such that any two relying parties cannot link the conversation to one user (i.e. be unlinkable). [SG-5] Verifier Leak Resilience : Be resilient to leaks from other relying parties,i.e. nothing that the verifier could possibly leak can help an attacker impersonate the user to a relying party. [SG-6] Authenticator Leak Resilience : Be resilient to leaks from other FIDO Authenticators i.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker impersonate any other user to a relying party. [SG-7] User Consent : Notify the user before a relationship with a new relying party is being established (requiring explicit consent). [SG-8] Limited PII : Limit to the absolute minimum the amount of the Personal Identifiable Information (PII) that can get exposed to the relying party. [SG-9] Attestable Properties : The relying party must be able to verify FIDO Authenticator model/type (in order to calculate the associated risk). [SG-10] DoS Resistance : Be resilient to the Denial of Service attacks, i.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase and therefore, the legitimate user will not be able to login successfully anymore. [SG-11] Forgery Resistance : Be resilient to the forgery attacks (impersonation attacks), i.e. prevent attackers from attempting to modify intercepted communications in order to masquerade as the legitimate user and be able to log in to the system. [SG-12] Parallel Session Resistance : Be resilient to the parallel session attacks. Without knowing a user\u2019s authentication credential, an attacker can masquerade as a legitimate user. This can be done by creating a valid authentication message out of some eavesdropped communication between the user and the server. [SG-13] Forwarding Resistance : Be resilient to the forwarding and replay attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. This attacker can replay or forward the intercepted messages. [SG-14] Transaction Non-Repudiation : Provide strong cryptographic non-repudiation for secure transactions. [SG-15] Respect for Operating Environment Security Boundaries : Ensure that the registrations and the private keys, as a shared system resource, are appropriately protected according to the operating environment privilege boundaries on the FIDO user device. [SG-16] Assessable Level of Security : Ensure that the design and implementation of the authenticator allow the testing laboratory/FIDO Alliance to assess the level of security provided by the authenticator.","title":"Login Protocol"},{"location":"services/login-protocol/#login-protocol","text":"","title":"Login Protocol"},{"location":"services/login-protocol/#introduction","text":"The login protocol is based on the signature protocol, in which a user signs a packet using an authorized kSign key. For the login case, the user desires to assert a particular identity (an Ethereum address in this case) to a server so that s/he is allowed access to the service while being identified.","title":"Introduction"},{"location":"services/login-protocol/#assumptions","text":"Secure connection between wallet and server. Secure connection between web client and server. Wallet authenticates the server in the connection. Web client authenticates the server in the connection.","title":"Assumptions"},{"location":"services/login-protocol/#what-is-required","text":"Server authenticates the Ethereum address and Ethereum name from the wallet. The user transfers the authentication from the wallet to the web client.","title":"What is Required?"},{"location":"services/login-protocol/#protocol-flow","text":"Challenges contain a cryptographic nonce and have a timeout that indicates the validity of the nonce in the challenge. A signed challenge with a timed out nonce must be rejected by the server. The server must store a list of the nonces that have not timed out and have not been signed yet to guarantee the freshness. A cryptographic nonce must be generated securely and must be long enough to avoid collisions (we use 256 bits).","title":"Protocol Flow"},{"location":"services/login-protocol/#signature-protocol-v01-specifications","text":"A signature may be requested as follows: { header: { typ: iden3.sig.v0_1 } body: { type: TYPE data: DATA } } Depending upon the signature protocol specifications, a user generates a packet that may contain data from the signature request or can be created from scratch. The packet contains a header and a payload, is serialized, and signed following the JWS standard . Usually, the form is filled in by the user, and data is copied from a request. The structures of the data and the form in the payload are specified by the type (what is being signed) in the payload. The rest of the elements are specified by the typ (signature packet) in the header. JWS_PAYLOAD = { type: TYPE data: DATA form: FORM ksign: str # ksing public key in compressed form proofKSing: proofClaim # Proof of authorize k sign claim (which contains the public key in compressed form) } JWS_HEADER = { typ: iden3.sig.v0_1 iss: str # Ethereum Address iat: uint # issued at time, unix timestamp exp: uint # expiration time, unix timestamp alg: ? # algorithm } JWS_SIGN(JWS_HEADER, JWS_PAYLOAD) Each signature request type has a view representation for the user, where the data and form are presented. Some of the values may be hidden from the user when necessary, but only if doing so doesn\u2019t compromise the security of the user. In the request view, the user has the ability to pick some elements of the form . ksign is the compressed public key of a secp256k ECDSA key pair. The proofKSing contains a KSign Authorize Claim for a secp256k public key. As JWS_HEADER.alg , we will use a custom algorithm (not defined in the JWS standard): \u201cEK256K1\u201d, which is ECDSA with secp256k1 curve and keccak as a hash function, the same signature algorithm configuration as is used in Ethereum.","title":"Signature Protocol v0.1: Specifications"},{"location":"services/login-protocol/#auxiliary-data-structures","text":"proofClaim: { signature: signature # Relay root + date signed by relay date: uint leaf: claim proofs: proofClaimPartial[] } proofClaimPartial: { mtp0: mtp # merkle tree proof of leaf existence mtp1: mtp # merkle tree proof of leaf non-existence root: key # merkle tree root aux: nil | { ver: uint, era: uint, idAddr: str } # Necessary data to construct SetRootClaim from root } Usually, the relay returns the proofClaim data structure to prove that a claim is valid and is in the Merkle tree.","title":"Auxiliary Data Structures"},{"location":"services/login-protocol/#identity-assertion-v01-specifications","text":"payload: type: iden3.iden_assert.v0_1 data: { challenge: nonce # 256 bits in base64 timeout: uint # seconds origin: str # domain } form: { ethName: str # ethereumName proofAssignName: proofClaim # proof of claim Assign Name for ethName } A session id, if required, can be computed from the challenge. This session id can be used to link the communication between the web service and the wallet service. view: type: Identity Assertion data: { origin: str # domain } form: { ethName: str # ethereum name }","title":"Identity Assertion v0.1: Specifications"},{"location":"services/login-protocol/#algorithms","text":"In the following sections, we will show an overview of the steps of the algorithms used for verification of the proofs and signatures used in the login protocol. The algorithms below consider the case in which there is a single trusted entity (identified by relayPk ) that acts as a relay and as a domain name server.","title":"Algorithms"},{"location":"services/login-protocol/#signature-verification-algorithm","text":"VerifySignedPacket(jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsHeader.typ is 'iden3.sig.v0_1' 2. Verify jwsHeader.alg is 'EK256K1' 3. Verify that jwsHeader.iat <= now() < jwsHeader.exp 4. Verify that jwsPayload.ksign is in jwsPayload.proofKSign.leaf 5. Verify that jwsHeader.iss is in jwsPayload.proofKSign 6. Verify that signature of JWS(jwsHeader, jwsPayload) by jwsPayload.ksign is signature 7. VerifyProofOfClaim(jwsPayload.proofKSign, relayPk) In step 4 above, we verify that the ksign used to sign the packet is authorized by the user and is identified by the jwsHeader.iss Ethereum address.","title":"Signature Verification Algorithm"},{"location":"services/login-protocol/#iden-assert-verification-algorithm","text":"VerifyIdenAssertV01(nonceDB, origin, jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsPayload.type is 'iden3.iden_assert.v0_1' 2. Verify jwsPayload.data.origin is origin 3. Verify jwsPayload.data.challenge is in nonceDB and hasn't expired, delete it 4. Verify that jwsHeader.iss and jwsPayload.form.ethName are in jwsPayload.proofAssignName.leaf 5. VerifyProofOfClaim(jwsPayload.form.ethName, relayPk)","title":"Iden Assert Verification Algorithm"},{"location":"services/login-protocol/#proof-of-claim-verification","text":"VerifyProofOfClaim(p, relayPk): 1. Verify signature of p.proofs[-1].root by relayPk is p.signature let leaf = p.leaf 2. loop for each proof in p.proofs: 2.1 Verify proof.mtp0 is existence proof 2.2 Verify proof.mtp0 with leaf and proof.root 2.3 Verify proof.mtp1 is non-existence proof 2.4 Verify proof.mtp1 with ClaimIncrementVersion(leaf) and proof.root leaf = NewClaimSetRootClaim(p.root, p.aux.ver, p.aux.era, p.aux.ethAddr)","title":"Proof of Claim Verification"},{"location":"services/login-protocol/#iden3js-protocols","text":"","title":"iden3js Protocols"},{"location":"services/login-protocol/#login-identity-assertion","text":"Wallet Service + + | signatureRequest | | <-------------------------------------+ | | | | +---+ | | | | | |sign packet | | | | | <---+ | | signedPacket | | +-------------------------------------> | | | | +---+ | | verify | | | signedPacket| | | | | | +---> | | | | ok | | <-------------------------------------+ | | | | | | | + + Read the login protocol specifications here:","title":"Login (Identity Assertion)"},{"location":"services/login-protocol/#define-new-noncedb","text":"const nonceDB = new iden3.protocols.NonceDB();","title":"Define New NonceDB"},{"location":"services/login-protocol/#generate-new-request-for-identity-assert","text":"Input nonceDB : NonceDB class object origin : Domain of the emitter of the request timeout : Unix time format, valid until that date. For example, we can use 2 minutes ( 2*60 seconds) Output signatureRequest : Object {.sourceCode .js} const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2*60); The nonce of the signatureRequest can be accessed as: const nonce = signatureRequest.body.data.challenge; // nonce is the string containing the nonce value We can add auxiliar data to the nonce in the nonceDB only one time: const added = nodeDB.addAuxToNonce(nonce, auxdata); // added is a bool confirming if the aux data had been added.","title":"Generate New Request for Identity Assert"},{"location":"services/login-protocol/#sign-packet","text":"input signatureRequest : object generated in the newRequestIdenAssert function userAddr : Ethereum address of the user who signs the data packet ethName : name assigned to the userAddr proofOfEthName : proofOfClaim of the ethName kc : iden3.KeyContainer object ksign : KOperational authorized for the userAddr proofOfKSign : proofOfClaim of the ksign expirationTime : Unix time format, signature will be valid until that date output signedPacket : String {.sourceCode .js} const expirationTime = unixtime + (3600 * 60); const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr, ethName, proofOfEthName, kc, ksign, proofOfKSign, expirationTime);","title":"Sign Packet"},{"location":"services/login-protocol/#verify-signed-packet","text":"input nonceDB : NonceDB class object origin : Domain of the emitter of the request signedPacket : Object generated in the signIdenAssertV01 function output nonce : Nonce object of the signedPacket that has been deleted from the nonceDB when the signedPacket is verified. If the verification fails, the nonce will be undefined. {.sourceCode .js} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket);","title":"Verify Signed Packet"},{"location":"services/login-protocol/#rationale","text":"In the following sections, you will find references to a few protocols on which our login protocol relies or takes inspiration from.","title":"Rationale"},{"location":"services/login-protocol/#signature-format","text":"Use JSON to encode the object that will be signed.","title":"Signature Format"},{"location":"services/login-protocol/#json-signing-formats","text":"https://medium.facilelogin.com/json-message-signing-alternatives-897f90d411c JSON Web Signature (JWS) Doesn\u2019t need canonicalization Allows signing arbitrary data (not only JSON) Widely used JSON Cleartext Signature (JCS) Concise Binary Object Representation (CBOR) Object Signing https://matrix.org/docs/spec/appendices.html#signing-json Matrix JSON Signing Allows having multiple signatures with different protocols for a single JSON","title":"JSON Signing Formats"},{"location":"services/login-protocol/#possible-attacks","text":"See WebAuth API, FIDO Threat Analysis","title":"Possible attacks"},{"location":"services/login-protocol/#references","text":"https://en.wikipedia.org/wiki/OpenID https://en.wikipedia.org/wiki/OpenID_Connect https://en.wikipedia.org/wiki/IndieAuth https://fidoalliance.org/how-fido-works/","title":"References"},{"location":"services/login-protocol/#webauth-api","text":"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API https://w3c.github.io/webauthn/ https://www.w3.org/TR/webauthn/ https://www.webauthn.io/ (Demo)","title":"WebAuth API"},{"location":"services/login-protocol/#fido-security-guarantees-and-how-they-are-achieved","text":"https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#relation-between-measures-and-goals","title":"FIDO Security Guarantees and How They are Achieved:"},{"location":"services/login-protocol/#fido-threat-analysis-and-mitigations","text":"https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#threat-analysis Currently (2018-01-08) there\u2019s no support for iOS (Safari): https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#Browser_compatibility","title":"FIDO Threat Analysis and Mitigations:"},{"location":"services/login-protocol/#criticism","text":"https://www.scip.ch/en/?labs.20180424","title":"Criticism:"},{"location":"services/login-protocol/#example-code-of-server-verification","text":"https://github.com/duo-labs/webauthn/blob/fa6cd954884baf24fc5a51656ce21c1a1ef574bc/main.go#L336 https://w3c.github.io/webauthn/#verifying-assertion","title":"Example Code of Server Verification:"},{"location":"services/login-protocol/#appendix","text":"","title":"Appendix"},{"location":"services/login-protocol/#the-fido-protocols-security-goals","text":"","title":"The FIDO Protocols: Security Goals"},{"location":"services/login-protocol/#sg-1","text":"Strong User Authentication : Authenticate (recognize) a user and/or a device to a relying party with high (cryptographic) strength.","title":"[SG-1]"},{"location":"services/login-protocol/#sg-2","text":"Credential Guessing Resilience : Provide robust protection against eavesdroppers, e.g. be resilient to physical observation, resilient to targeted impersonation, and resilient to throttled and unthrottled guessing.","title":"[SG-2]"},{"location":"services/login-protocol/#sg-3","text":"Credential Disclosure Resilience : Be resilient to phishing attacks and real-time phishing attacks including resilience to online attacks by adversaries that are able to actively manipulate network traffic.","title":"[SG-3]"},{"location":"services/login-protocol/#sg-4","text":"Unlinkablity : Protect the protocol conversation such that any two relying parties cannot link the conversation to one user (i.e. be unlinkable).","title":"[SG-4]"},{"location":"services/login-protocol/#sg-5","text":"Verifier Leak Resilience : Be resilient to leaks from other relying parties,i.e. nothing that the verifier could possibly leak can help an attacker impersonate the user to a relying party.","title":"[SG-5]"},{"location":"services/login-protocol/#sg-6","text":"Authenticator Leak Resilience : Be resilient to leaks from other FIDO Authenticators i.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker impersonate any other user to a relying party.","title":"[SG-6]"},{"location":"services/login-protocol/#sg-7","text":"User Consent : Notify the user before a relationship with a new relying party is being established (requiring explicit consent).","title":"[SG-7]"},{"location":"services/login-protocol/#sg-8","text":"Limited PII : Limit to the absolute minimum the amount of the Personal Identifiable Information (PII) that can get exposed to the relying party.","title":"[SG-8]"},{"location":"services/login-protocol/#sg-9","text":"Attestable Properties : The relying party must be able to verify FIDO Authenticator model/type (in order to calculate the associated risk).","title":"[SG-9]"},{"location":"services/login-protocol/#sg-10","text":"DoS Resistance : Be resilient to the Denial of Service attacks, i.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase and therefore, the legitimate user will not be able to login successfully anymore.","title":"[SG-10]"},{"location":"services/login-protocol/#sg-11","text":"Forgery Resistance : Be resilient to the forgery attacks (impersonation attacks), i.e. prevent attackers from attempting to modify intercepted communications in order to masquerade as the legitimate user and be able to log in to the system.","title":"[SG-11]"},{"location":"services/login-protocol/#sg-12","text":"Parallel Session Resistance : Be resilient to the parallel session attacks. Without knowing a user\u2019s authentication credential, an attacker can masquerade as a legitimate user. This can be done by creating a valid authentication message out of some eavesdropped communication between the user and the server.","title":"[SG-12]"},{"location":"services/login-protocol/#sg-13","text":"Forwarding Resistance : Be resilient to the forwarding and replay attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. This attacker can replay or forward the intercepted messages.","title":"[SG-13]"},{"location":"services/login-protocol/#sg-14","text":"Transaction Non-Repudiation : Provide strong cryptographic non-repudiation for secure transactions.","title":"[SG-14]"},{"location":"services/login-protocol/#sg-15","text":"Respect for Operating Environment Security Boundaries : Ensure that the registrations and the private keys, as a shared system resource, are appropriately protected according to the operating environment privilege boundaries on the FIDO user device.","title":"[SG-15]"},{"location":"services/login-protocol/#sg-16","text":"Assessable Level of Security : Ensure that the design and implementation of the authenticator allow the testing laboratory/FIDO Alliance to assess the level of security provided by the authenticator.","title":"[SG-16]"}]}